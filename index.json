[
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/trees/bus_tree/",
	"title": "Bus tree",
	"tags": [],
	"description": "",
	"content": "The bus tree The vspec bus tree is a copy of a VSS tree.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/trees/car_tree/",
	"title": "Car tree",
	"tags": [],
	"description": "",
	"content": "The Car tree The Car tree is identical to the VSS tree, version 5.0. The vspecPreprocessor can be configured to modify it by e. g. changing the seat layout to a ragged matrix with 2 and 3 seats in the two rows, but it can also configure it to be an exact copy of the standard VSS tree.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/trees/driver_tree/",
	"title": "Driver tree",
	"tags": [],
	"description": "",
	"content": "The Driver tree The vspec driver tree is used to represent the truck driver data. The source for this driver data is the truck dirver recording unit (in europe often named tachograph, in the US xxx). As the driver recording unit may hold data not only for the current driver but also for previous drivers, there might be several instances of this driver tree, one for each driver that the driver recording unit has a record on. The data from these different instances should be accessible via the interface that is exposed by vehicle server managing the access to the driver recording device.\nCurrently the vspec Driver tree only contains empty variants for to enable support for the different data that is required by the EU and the US legislation, respectively.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "Examples of creating different vehicle type trees and how to use them in a client-server scenario Below is a list of examples of creating different vehicle type trees, and in some cases also how to use the trees in scenario with a client that over an interface access data represented in the tree.\nCreation of truck and trailer trees that are used in a client-server scenario using VISS as the interface "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/tools/him_configurator/",
	"title": "HIM configurator",
	"tags": [],
	"description": "",
	"content": "HIM configurator Build instructions To build the HIM configurator it is necessary to first instal the Golang build system. Searching on \u0026ldquo;install golang\u0026rdquo; will lead to many matches of which one is:\nhttps://go.dev/doc/install\nTo build the HIM configurator, open a terminal and go to the spec/trees directory where the himConfigurator.go is stored, and issue the command\n$ go build -o himConfigurator\nInitializing the Python virtual environment The HIM configurator uses the VSS-tools exporters for the generation of the transformed vspec files. According to the instructions for this tool a Python virtual environment should be set up in which it then is run when exporting the vspec files to other formats. The work flow is to the first time initialize this environment, and then every time before running the HIM configurator activate the virtual environment, and when done terminate the virtual environment.\nIf the virtual environment has not been set up before on the computer, it could e. g. already has been used in a VSS context to transform vspec files, then the first time it needs to be created and configured. To create it issue the following command:\n$ python3 -m venv ~/.venv Then it needs to be configured for VSS-tools, which shall be done with the environment activated:\n$ source ~/.venv/bin/activate (.venv)$ pip install --pre vss-tools (.venv)$ deactivate The above is only needed to be done once. It might be necessary to install both python and pip if that is not already installed on the computer.\nTo then use the HIM configurator it is sufficient with activating the virtual environment before using the HIM configurator.\n$ source ~/.venv/bin/activate Then the HIM configurator can be run in the spec/trees directory with commands like:\n(.venv)$ ./himConfigurator -m binary -v Vehicle/Trailer/ Finally the environment shall be deactivated it after the use.\n(.venv)$ deactivate If the HIM configurator complains with error logs it may help to, one time, try the command:\n(.venv)$ pip install -e . A bash script file in the spec/trees directory, venv.sh, can be used instead of typing the commands manually in the terminal window. If this file is issued as shown below it responds with displaying the two supported usages.\n$ source venv.sh usage: source venv.sh startme|installme As shown it can either be used to install venv, which as described above is only needed to be run the very first time. The other alternative can thereafter be used to activate venv.\nUsing the HIM configurator Starting the HIM configurator with the command:\n(.venv)$ ./himConfigurator -h\nwill show the command line options that is possible to apply at startup.\nusage: print [-h|--help] [-m|--makecommand (all|yaml|json|csv|binary)] [-c|--configfile \u0026#34;\u0026lt;value\u0026gt;\u0026#34;] [-r|--rootdir \u0026#34;\u0026lt;value\u0026gt;\u0026#34;] [-s|--vspecsave] [-p|--preprocess] [-n|--noEnumSubst] [-d|--disableOverlays] [-t|--typefile \u0026#34;\u0026lt;value\u0026gt;\u0026#34;] HIM configurator Arguments: -h --help Print help information -m --makecommand Make command parameter must be either: all, yaml, json, csv, or binary. Default: yaml -c --configfile configuration file name. Default: himConfig-truck.json -r --rootdir path to vspec root directory. Default: Vehicle/VSS-core/ -s --vspecsave Saves the configured .vspec2 files with extension .vspec -p --preprocess Pre-process only, save configured vspec files. Do not run VSS-tools. -n --noEnumSubst No substitution of enum links to Datatype tree with actual datatypes -d --disableOverlays Disables VSS-tools overlay configurations -t --typefile type definition file name The -m command line option is used to set which VSS-tools exporter the configured tree should have. The value \u0026lsquo;all\u0026rsquo; leads to that all the exporters that are compatible with the HIM configurator are executed. If not used the default is \u0026lsquo;yaml\u0026rsquo;.\nThe -c command line option is used to select the HIM configurator file. This is useful when a tree has multiple configuration files. Default is himConfig-truck.json.\nThe -r command line option is used to set the path to the tree that should be used as input for the configuration. The path is relative to the tree directory, and should have the slash \u0026lsquo;/\u0026rsquo; character at the end of the path. If not used the default is \u0026lsquo;Vehicle/VSS-core/\u0026rsquo;.\nIf the -s command line option is set the the HIM configurator does not delete the vspec files that it generates from the vspec2 files that are found in the tree structure. If not set these vspec files are deleted after being used as input to the call of the VSS-tools exporter(s). If not used the default is false, i. e. not to save the files.\nWith the vspec files saved it becomes possible to run the VSS-tols exporters \u0026ldquo;manually\u0026rdquo; with the vspec root node as input. This might be helpful if the development environment is not a Linux compatible environment, or if there is a need to debug the VSS-tools processing, se below.\nThe -p command line option leads to that the HIM configurator does not issue a command to the VSS-tools exporters. The vspec files generated by the HIM configurator is saved, and the VSS-tools exporters can be activated \u0026ldquo;manually\u0026rdquo; with the pre-processed tree as input.\nThe -n command line option is used if substitution is not desired of the external datatype references with the actual enum definitions from the common Datatypes tree in the generated tree(s). However, VSS-tools currently does not accept the syntax using a reference.\nThe -d command line option is used to disable the overlays to be invoked to the VSS-tools exporter.\nThe -t command line option is used to include a type definition tree in the CLI to theVSS-tools. If the main tree includes a struct then its datatype shall be a path pointing to the struct in the type definition tree. VSS-tools then require that the type definition tree is available to verify the path.\nVSS-tools debug \u0026lsquo;in the development of the trees it might happen that errors are introduced in the vspec2/vspec files. There is some logging information saved in the spec/trees/exporterData/exporterLog.txt. The first line in that file shows the command that is issued to the VSS-tools vspec service. This can be copied and then issued manaually in a terminal window, in which case the more comprehensive error logging by the VSS-tools exporter will be available. However, for it to work the HIM configurator must have saved the vspec files by adding the -p CLI parameter to the HIM configurator command.\nCreation of a vehicle variant specific signal tree The HIM configurator enables a model where a \u0026ldquo;super tree\u0026rdquo; covering all variations that a vehicle may be equipped with, e. g. propulsion technology like ICE, PHEV, EV, etc. can be defined in the vspec files, then the HIM configurator can be used to create a \u0026ldquo;variant specific\u0026rdquo; vehicle signal tree from the variation point configuration in the himConfiguration.json file.\nUsage of a vehicle variant specific signal tree The output from the HIM configurator is the selected parts of the \u0026ldquo;vspec super tree\u0026rdquo; in a file with one of the supported formats. This file can then e. g. be used in a vehicle of the selected variant by a server that is managing the access to the signals. The server can then use the tree to \u0026ldquo;vet\u0026rdquo; client request - checking that the signal is present, whether it is read-only or read-write, that credentials are valid if access control is applied, etc. An example of a server using it like this is the VISS reference server.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/trees/trailer_tree/",
	"title": "Trailer tree",
	"tags": [],
	"description": "",
	"content": "The trailer tree The vspec trailer tree is a super tree that contains signal definitions for a large set of different trailer models. The HIM configurator is then used to create a signal tee for a specific trailer variant.\nThe different variants that are present in the vspec files are:\nFlatbed trailer: This trailer type has an open flat bed cargo unit. Box trailer: This trailer type has a cargo unit that is covered by walls and a roof. Tanker trailer: This trailer type has a cargo unit that is specicialized for carrying liquid cargos. Freezer trailer: This trailer type has a cargo unit that is specicialized for carrying cargos that require cooling. Specialized trailer: This trailer type has a cargo unit that does not match with any of the other types\u0026hellip; "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/examples/truck_trailer_viss/",
	"title": "Truck and trailer trees used in VISS access scenario",
	"tags": [],
	"description": "",
	"content": "Creation of truck and trailer trees that are used in a client-server scenario using VISS as the interface The following describes how a demo can be set up in which a client can read and write signals from a truck and a trailer that is connected to it using the VISS interface.\nThe two repos that are needed for this are the CVIS and the VISSR repos, so start with cloning these if not done earlier.\n$ git clone https://github.com/COVESA/commercial-vehicle-information-specifications.git\n$ git clone https://github.com/COVESA/vissr.git\nThe database that VISSR is configured to use must be installed on the computer. Redis is the default configuration.\nPlease see the docmentation of respective database for how to install if that is needed.\nThe vspecPreprocessor creates an overlay file that is then used together with a suitable vspec domain tree in a call to the VSS-tools exporter. To set up the environment required by the VSS-tools exporter the Python virtual environment, venv, must be activated. Assuming that venv is installed, if not please check here, the following command can be applied.\n$ source venv.sh startme\nVenv can when not needed anymore be deactivated by the command:\n(.venv)$ deactivate\nThe vspec tree for trucks in the CVIS/spec/trees/Vehicle/Truck directory, and the vspec tree for separate trailer trees in the CVIS/spec/trees/Vehicle/Trailer directory will be used. These trees are not yet complete signal reprensentations for trucks and trailers but as it is what we have available at this point let us use them. The vspecPreprocessor and the VSS-tools exporter will be used to generate binary format representations of the two trees as shown below. To generate the trailer overlay file apply the command:\n$ python3 vspecPreprocessor.py -i Config/Trailer/vehicleConfig-separateTrailer.json -o Config/Trailer/separateTrailer.vspec -s Config/Trailer/configScope-separateTrailer.json -v Vehicle/Trailer/SeparateTrailerSignalSpecification.vspec\nThen to generate the trailer binary file apply the command:\n$ vspec export binary -u Vehicle/Trailer/units.yaml -q Vehicle/Trailer/quantities.yaml -l Config/Trailer/separateTrailer.vspec -s Vehicle/Trailer/SeparateTrailerSignalSpecification.vspec -o Trailer.binary\nThe binary tree is then found in CVIS/spec/trees with the file name Trailer.binary.\nTo generate the truck binary tree apply the two commands below:\\\n$ python3 vspecPreprocessor.py -i Config/Truck/vehicleConfig-truck.json -o Config/Truck/truck.vspec -s Config/Truck/configScope.json -v Vehicle/Truck/TruckSignalSpecification.vspec\nvspec export binary -u Vehicle/Truck/units.yaml -q Vehicle/Truck/quantities.yaml -l Config/Truck/truck.vspec -s Vehicle/Truck/TruckSignalSpecification.vspec -o Truck.binary\nThe binary tree is then found in CVIS/spec/trees with the file name Truck.binary.\nIf human readable YAML trees are desired for inspection, exchange \u0026lsquo;binary\u0026rsquo; in the vspec commands above to \u0026lsquo;yaml\u0026rsquo; (in both exporter format and output file extension).\\\nThe binary format is the format that the VISSR server expects the trees to have. The directory VISSR/server/vissv2server/forest is the local repository for trees so copy the two files Truck.binary and Trailer.binary there. $ cp /CVIS/spec/trees/Truck.binary /VISSR/server/vissv2server/forest/Truck.binary\n$ cp /CVIS/spec/trees/Trailer.binary /VISSR/server/vissv2server/forest/Trailer.binary\nis to be replaced with the path on your device to the VISSR and CVIS root directories.\nIf you for some reason failed in creating the binary trees using the HIM configurator there are copies available in the CVIS/demodata directory.\nFor the VISSR server to register the binary trees at startup the file VISSR/server/vissv2server/viss.him must be modified to contain the information for these trees. The file CVIS/demodata/viss.him is configured or this, so it can be copied to the VISSR/server/vissv2server directory. If you do not want the viss.him file that is in this directory to be overwritten it needs to be renamed before the copy operation.\nTo enable a demo where a client can access dynamically changing signal values the feeder needs to be configured for this. The feder implementation in vissr/feeder/feeder-template/feederv3 can be started with a CLI parameter \u0026ldquo;-i truck-trailer-sim.json\u0026rdquo; where the file truck-trailer-sim.json contains the simulated signal data. More about configuring the simulation can be found here. A minimal simulation file truck-trailer-sim.json is available in the CVIS/demodata directory. This file can easily be extended with more signals and more samples per signal. Copy that file to vissr/feeder/feeder-template/feederv3.\nTo start the VISSR server and feeder copy the bash shell file CVIS/demodata/runtrucktrailer.sh to the VISSR directory. The command below will then start them using the mentioned simulator input to the feeder.\n$ ./runtrucktrailer.sh startme\nWhat is needed now is a client that can be used to issue requests for truck or trailer signals to the server. Teh VISSR repo has a number of clients in the VISSR/client/client-1.0 directories that can be used, either as is or as a code template to be modified.\nThe VISSR/client/client-1.0/Javascript/wsclient.html that uses the Websocket protocol can be used directly, by clicking on the file it will open in the browser. Start to enter the IP address of the server into the uppermost field and click on the Server IP button. If the server has the same IP address as this client then \u0026ldquo;localhost\u0026rdquo; can be written into the field instead.\nNow request messages can be copied into the field below followed by clicking on the Send button and the responses from the server will be shown below in the browser tab. Below is shown a few requests that can be used.\n{\u0026#34;action\u0026#34;:\u0026#34;get\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;Vehicle.TraveledDistance\u0026#34;,\u0026#34;requestId\u0026#34;:\u0026#34;232\u0026#34;} {\u0026#34;action\u0026#34;:\u0026#34;get\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;Vehicle.CurrentLocation\u0026#34;,\u0026#34;filter\u0026#34;:{\u0026#34;variant\u0026#34;:\u0026#34;paths\u0026#34;,\u0026#34;parameter\u0026#34;:[\u0026#34;Longitude\u0026#34;,\u0026#34;Latitude\u0026#34;]},\u0026#34;requestId\u0026#34;:\u0026#34;237\u0026#34;} {\u0026#34;action\u0026#34;:\u0026#34;subscribe\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;Trailer1.Chassis.Axle.Row1.Wheel.Pos7.Tire.Temperature\u0026#34;,\u0026#34;filter\u0026#34;:{\u0026#34;variant\u0026#34;:\u0026#34;timebased\u0026#34;,\u0026#34;parameter\u0026#34;:{\u0026#34;period\u0026#34;:\u0026#34;1000\u0026#34;}},\u0026#34;requestId\u0026#34;:\u0026#34;246\u0026#34;} {\u0026#34;action\u0026#34;:\u0026#34;unsubscribe\u0026#34;,\u0026#34;subscriptionId\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;requestId\u0026#34;:\u0026#34;240\u0026#34;} Other websocket request examples can be found in VISSR/client/client-1.0/Javascript/appclient_commands.txt that can be modified to signal paths used in this demo.\nTo simulate that one more trailer is towed by the truck the steps below can be followed.\nIssue a command to stop the server and feeder:\n$ ./runtrucktrailer.sh stopme\nAdd one more trailer tree. This can be done by first creating another trailer binary tree using the HIM configurator, but a shortcut is possible by using the same binary tree as for the first trailer. To do this add the following rows to the viss.him file:\nHIM.Trailer2: type: direct domain: Automotive.Trailer.Data version: 0.1.0 local: forest/Trailer.binary public: https://github.com/COVESA/commercial-vehicle-information-specifications/tree/main/spec/trees/Vehicle/Trailer description: A tree for the second trailer in the train. The snippet above can be inserted at the top or at the bottom, or in between any two tree declarations.\nTo get back any values from get requests to Trailer2 the truck-trailer-sim.json file needs to be updated with that.\nThen restart the server and feeder:\n$ ./runtrucktrailer.sh startme\nSignal data from the new trailer can now be accessed using requests with paths having Trailer2 as the root node name (the first segment name in the path).\nThe VISSR server supports \u0026lsquo;forest inquiry\u0026rsquo; requests as shown below. This is not part of the VISSv3.0 spec but may become part of a next version.\n{\u0026#34;action\u0026#34;:\u0026#34;get\u0026#34;, \u0026#34;path\u0026#34;:\u0026#34;HIM\u0026#34;, \u0026#34;filter\u0026#34;:{\u0026#34;variant\u0026#34;:\u0026#34;metadata\u0026#34;, \u0026#34;parameter\u0026#34;:\u0026#34;0\u0026#34;}, \u0026#34;requestId\u0026#34;:\u0026#34;1957\u0026#34;} The response will contain the metadata from the viss.him file in JSON format, except the \u0026rsquo;local\u0026rsquo; property that is excluded as it is server internal data.\nThe browser tab rendered by wsclient.html may look something like below, depending on which requests that have been issued to the server. "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/trees/truck_tree/",
	"title": "Truck tree",
	"tags": [],
	"description": "",
	"content": "The truck tree The vspec truck tree is identical to the VSS tree, version 5.0, with the exception that the Chassis/Chassis.vspec is changed to include the AxleFeature branches.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/tools/vspecpreprocessor/",
	"title": "vspecPreprocessor",
	"tags": [],
	"description": "",
	"content": "vspecPreprocessor Usage As the vspecPreprocessor is written in Python it does not have o be compiled in a first step but can be run in interpreter mode. To get help on the different CLI parameters it supports, open a terminal, navigate to the spec/trees directory and issue the command:\n$ python3 vspecPreprocessor.py -h\nThis will lead to the following being displayed:\nusage: python3 vspecPreprocessor.py [-h] -i INPUTFILE [-s SCOPEFILE] [-o OUTPUTFILE] [-v VSPECFILE] [-f {yaml,json,binary}] The VspecPreprocessor tool configures the vspec files by creating overlays to be submitted with the vspec files to VSS-tools options: -h, --help show this help message and exit -i INPUTFILE, --inputfile INPUTFILE JSON file containing configuration data -s SCOPEFILE, --scopefile SCOPEFILE JSON file defining the scope of the different config features -o OUTPUTFILE, --outputfile OUTPUTFILE Overlay vspec file to be used with VSS-tools -v VSPECFILE, --vspecfile VSPECFILE Root vspec file of the tree -f {yaml,json,binary}, --format {yaml,json,binary} Exporter output format The vspecPreprocessor requires two files as input, the INPUTFILE and the SCOPEFILE. These are described in respective sections below.\nIts output is found in the OUTPUTFILE which is a VSS-tools overlays file containing the directives to configure the vspec domain tree that it is combined with as input to the VSS-tools exporter.\nCurrently the vspecPreprocessor does not issue the command to the VSS-tools exporter, it has to be done manually in a following step. However, if a VSPECFILE pointing to the root vspec file of the domain tree the vspecPreprocessor will display the command that is to be used. It will then by default select the YAML exporter, but with the -f CLI parameter another exporter can be selected.\nInitializing the Python virtual environment The vspecPreprocessor creates input to the VSS-tools exporters for the generation of the transformed vspec files. According to the instructions for VSS-tools tool a Python virtual environment should be set up in which it then is run when exporting the vspec files to other formats. The work flow is to the first time initialize this environment, and then every time before running a VSS-tools exporter activate the virtual environment, and when done terminate the virtual environment.\nIf the virtual environment has not been set up before on the computer, it could e. g. already has been used in a VSS context to transform vspec files, then the first time it needs to be created and configured. To create it issue the following command:\n$ python3 -m venv ~/.venv Then it needs to be configured for VSS-tools, which shall be done with the environment activated:\n$ source ~/.venv/bin/activate (.venv)$ pip install --pre vss-tools (.venv)$ deactivate The above is only needed to be done once. It might be necessary to install both python and pip if that is not already installed on the computer.\nTo then use the vspecPreprocessor it is sufficient with activating the virtual environment before using the vspecPreprocessor.\n$ source ~/.venv/bin/activate Then the VSS-tools exporter can be run with commands like:\n(.venv)vspec export yaml -u Vehicle/Truck/units.yaml -q Vehicle/Truck/quantities.yaml -l Config/Truck/truck.vspec -s Vehicle/Truck/TruckSignalSpecification.vspec -o cvis.yaml When done with VSS-tools the environment can be deactivated with the command.\n(.venv)$ deactivate If the VSS-tools exporter complains with error logs it may help to, one time, try the command:\n(.venv)$ pip install -e . A bash script file in the spec/trees directory, venv.sh, can be used instead of typing the commands manually in the terminal window. If this file is issued as shown below it responds with displaying the two supported usages.\n$ source venv.sh usage: source venv.sh startme|installme As shown it can either be used to install venv, which as described above is only needed to be run the very first time. The other alternative can thereafter be used to activate venv.\nvspecPreprocessor example input files The directory spec/trees/Config contains example input files for some of the vspec trees that can be found under the spec/trees/Vehicle directory.\nTruck input files The vehicleConfig-truck.json and the configScope.json are examples of INPUTFILE and SCOPEFILE, respectively.\nAn example of their usage as input to the vspecPreprocessor is found in the vspecPreprocessor usage examples section below.\nTrailer input files This directory contains two sets of input files.\nOne will generate an overlay to be used together with a vspec tree representing a separate, standalone tree.\nThe other will generate an overlay to be used together with a vspec tree representing a tree containing multiple trailers.\nTo generate an overlay file for a separate trailer tree the vehicleConfig-separateTrailer.json and the configScope-separateTrailer.json are examples of INPUTFILE and SCOPEFILE, respectively.\nTo generate an overlay file for a tree containing multiple trailers the vehicleConfig-multipleTrailers.json and the configScope-multipleTrailers.json are examples of INPUTFILE and SCOPEFILE, respectively.\nExamples of their respective usage as input to the vspecPreprocessor is found in the vspecPreprocessor usage examples section below.\nCar input files The vehicleConfig.json and the configScope.json are examples of INPUTFILE and SCOPEFILE, respectively.\nAn example of their usage as input to the vspecPreprocessor is found in the vspecPreprocessor usage examples section below.\nvspecPreprocessor usage examples Below follows a few usage examples together with what the vspecPreprocessor displays in the terminal. A reference to the respective VSPECFILE is used to show the command that can be issue to the VSS-tools exporter. The default yaml output format is used.\nCreate overlay for a truck. $ python3 vspecPreprocessor.py -i Config/Truck/vehicleConfig-truck.json -o Config/Truck/truck.vspec -s Config/Truck/configScope.json -v Vehicle/Truck/TruckSignalSpecification.vspec Overlay configuration saved to Config/Truck/truck.vspec Exporter command: vspec export yaml -u Vehicle/Truck/units.yaml -q Vehicle/Truck/quantities.yaml -l Config/Truck/truck.vspec -s Vehicle/Truck/TruckSignalSpecification.vspec -o cvis.yaml Create overlay for a separate trailer. $ python3 vspecPreprocessor.py -i Config/Trailer/vehicleConfig-separateTrailer.json -o Config/Trailer/separateTrailer.vspec -s Config/Trailer/configScope-separateTrailer.json -v Vehicle/Trailer/SeparateTrailerSignalSpecification.vspec Overlay configuration saved to Config/Trailer/separateTrailer.vspec Exporter command: vspec export yaml -u Vehicle/Trailer/units.yaml -q Vehicle/Trailer/quantities.yaml -l Config/Trailer/separateTrailer.vspec -s Vehicle/Trailer/SeparateTrailerSignalSpecification.vspec -o cvis.yaml Create overlay for multiple trailers in one tree. $ python3 vspecPreprocessor.py -i Config/Trailer/vehicleConfig-multipleTrailers.json -o Config/Trailer/multipleTrailers.vspec -s Config/Trailer/configScope-multipleTrailers.json -v Vehicle/Trailer/MultipleTrailersSignalSpecification.vspec Overlay configuration saved to Config/Trailer/multipleTrailers.vspec Exporter command: vspec export yaml -u Vehicle/Trailer/units.yaml -q Vehicle/Trailer/quantities.yaml -l Config/Trailer/multipleTrailers.vspec -s Vehicle/Trailer/MultipleTrailersSignalSpecification.vspec -o cvis.yaml Create overlay for a passenger car. $ python3 vspecPreprocessor.py -i Config/Car/vehicleConfig.json -o Config/Car/car.vspec -s Config/Car/configScope.json -v Vehicle/Car/VehicleSignalSpecification.vspec Overlay configuration saved to Config/Car/car.vspec Exporter command: vspec export yaml -u Vehicle/Car/units.yaml -q Vehicle/Car/quantities.yaml -l Config/Car/car.vspec -s Vehicle/Car/VehicleSignalSpecification.vspec -o cvis.yaml vspecPreprocessor features The features supported by the vspecPreprocessor comes from what features the HIM configurator supported. Further features are in the planning, such as configuration of default values for attribute signals, definition of allowed values in a type definition tree (to make them reusable in a robust way).\nInstantiation of ragged matrices A ragged matrix contains rows with varying number of columns in the different rows. This is needed for the configuration of e. g. truck axle/wheel layouts where axles typically have different number of wheels. Another example is seat position layouts in passenger cars, busses, etc.\nInstantiation is supported for both 2-dimensional and 3-dimensional matrices. The two examples above are both 2-dimensional, a 3-dimensional example is the instantiation of multiple trailers in the same tree, which each contains an axle/wheel configuration. An example of how the configuration of axle/wheels can look in the INPUTFILE is shown below.\n\u0026#34;instances\u0026#34;: [ { \u0026#34;Axle\u0026#34;: [ [ \u0026#34;Axle10\u0026#34;, \u0026#34;Axle12\u0026#34; ], [ [ \u0026#34;Pos3\u0026#34;, \u0026#34;Pos13\u0026#34; ], [ \u0026#34;Pos4\u0026#34;, \u0026#34;Pos12\u0026#34; ] ] ] } ] Here two axles are configured with two wheels each but on different positions. A snippet of a 3-dimensional instantiation example can look in the INPUTFILE is shown below.\n\u0026#34;Trailers\u0026#34;: [ { \u0026#34;Trailer1\u0026#34;: { \u0026#34;Axle\u0026#34;: [ [ \u0026#34;Axle1\u0026#34;, ... The instance configuration data in the INPUTFILE must be complementd with data in the SCOPEFILE as the INPUTFILE data does not say anything of where in the tree this should be applied, i. e. the missing parts to be able to synthesize a complete path. For the 2-dimensional example above the SCOPEFILE data could look like below.\n\u0026#34;instance-scope\u0026#34;: [ { \u0026#34;Axle\u0026#34;: [ \u0026#34;Trailer.Chassis.Axle\u0026#34;, \u0026#34;.Wheel\u0026#34; ] } ] The key-name \u0026ldquo;Axle\u0026rdquo; is the logical connection between the two files. The two elements of the Axle-array are used to synthesize a path with the pattern:\\\nTrailer.Chassis.Axle.\u0026lt;Data from Axle-element 1\u0026gt;.Wheel.\u0026lt;Data from Axle-element 2, 3, etc\u0026gt;\\ Similarly for the 3-dimensional example the SCOPEFILE data could look like below.\n\u0026#34;Trailers\u0026#34;: [ \u0026#34;Trailers\u0026#34;, \u0026#34;.Chassis.Axle\u0026#34;, \u0026#34;.Wheel\u0026#34; ] This is then used to synthesize the following path pattern:\\\nTrailers.\u0026lt;Key-name from Trailers objects\u0026gt;.Chassis.Axle.\u0026lt;Data from Axle-element 1 from Trailers objects\u0026gt;.Wheel.\u0026lt;Data from Axle-element 2, 3, etc from Trailers objects\u0026gt;\\ Configuration of different variants A vspec tree may contain branches defining e. g. both electric and internal combustion engines. If a tree is then to be configured for an electric engine only, the internal combustion engine branch needs to be removed, and possibly an attribute needs to be set to \u0026lsquo;ELECTRIC\u0026rsquo;, etc.\nAn example of how variant configuration is expressed in the INPUTFILE is shown below.\n\u0026#34;variants\u0026#34;: [ { \u0026#34;TrailerType\u0026#34;: \u0026#34;SEMI_TRAILER\u0026#34; } ] The symbolic name of the variant to be configured is in this case TrailerType. The available different variant selections for TrailerType are defined in the SCOPEFILE, in this example the SEMI_TRAILER was selected. Below is shown a snippet of the list available TrailerType selections in the SCOPEFILE.\n\u0026#34;variant-scope\u0026#34;: [ { \u0026#34;TrailerType\u0026#34;: { \u0026#34;SEMI_TRAILER\u0026#34;: [ { \u0026#34;Path\u0026#34;: \u0026#34;Trailer.TrailerType\u0026#34;, \u0026#34;Directive\u0026#34;: \u0026#34; default: \u0026#39;SEMI_TRAILER\u0026#39;\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Configures the trailer tree as a SEMI_TRAILER\u0026#34; } ], A variant selection consists of an array of JSON objects each containing the key-value pairs Path, Directive abd Description.\nPath points to the node in the tree that is to be modified.\nDirective holds the operation that is to be applied to the node.\nDescription is only informative, it is not used by the tool.\nThe variant selection can contain any number of these JSON objects, they can be applied to any nodes in the tree, also multiple times on the same node.\nVariant selections may require large variant selection lists if it is to be applied to nodes that was created by an instantiation in the same configuration. For that the instance variation feature is a better choice.\nConfiguration of different variants on instantiated branches This is on a high level the same feature as the variant configuration described above but as it requires different input to the vspecPreprocessor it is represented as a separate feature. An example is the configuration of \u0026lsquo;axle features\u0026rsquo; that could be found on different axles of a truck or trailer where one axle might support steering capability, another axle supports capability to be lifted from the road surface, an yet another to supports driving power.\nThe vspecPreprocessor does not currently support the instance-variant feature when the instantiation feature is used to create a 3-dimensional matrix.\nAn example of how instance variant configuration is expressed in the INPUTFILE is shown below.\n\u0026#34;instance-variants\u0026#34;: [ { \u0026#34;AxleFeature\u0026#34;: [\u0026#34;LIFT\u0026#34;, \u0026#34;Axle10\u0026#34;] }, { \u0026#34;AxleFeature\u0026#34;: [\u0026#34;STEER\u0026#34;, \u0026#34;Axle12\u0026#34;] } ] The symbolic name of the instance variant to be configured is in this case AxleFeature. The available different variant selections for AxleFeature are defined in the SCOPEFILE, in this example LIFT was selected for Axle10, and STEER was selected for Axle12. Below is shown a snippet of the list available AxleFeature selections in the SCOPEFILE.\n\u0026#34;instance-variant-scope\u0026#34;: [ { \u0026#34;AxleFeature\u0026#34;: { \u0026#34;STEER\u0026#34;: [ { \u0026#34;Path\u0026#34;: \u0026#34;Trailer.Chassis.Axle.X2.Steerable\u0026#34;, \u0026#34;Directive\u0026#34;: \u0026#34; delete: no\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Configures the axle feature for a specific instance to STEER.\u0026#34; }, { \u0026#34;Path\u0026#34;: \u0026#34;Trailer.Chassis.Axle.X2.Liftable\u0026#34;, \u0026#34;Directive\u0026#34;: \u0026#34; delete: yes\u0026#34; }, { \u0026#34;Path\u0026#34;: \u0026#34;Trailer.Chassis.Axle.X2.Driving\u0026#34;, \u0026#34;Directive\u0026#34;: \u0026#34; delete: yes\u0026#34; } ], The content of an instance variant selection has the same format as for the variant selections, see above for the description of it.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/",
	"title": "Commercial Vehicle Information Specifications",
	"tags": [],
	"description": "",
	"content": "Commercial Vehicle Information Specifications Overview The ambition of the CVIS project is to develop a framework that can be used to define signal trees for different vehicle types, and then to use this framework to develop signal trees for vehicle types as e. g. Trucks, Trailers, Buses, and Passenger cars. The trees for these vehicle types shall share as much as possible of signals that can be commonly defined. The basis for common signals shall be the VSS tree. This tree has a focus on signals for passenger cars, but a significant part of these can very well be shared with the other vehicle types.\nThe CVIS project uses the Resource profile of the Hierarchical Information Model [HIM), which is fully compatible with the VSS rule set.\nTrees for many vehicle types, such as passenger cars, trucks, vans, pickups, etc. can be based on the same \u0026ldquo;base tree\u0026rdquo; and for this the VSS vspec tree is used.\nTo enable the different modifications that are needed to \u0026ldquo;reshape\u0026rdquo; the VSS-tree from its passenger car centric structure to a tree that represents other vehicle types a tool is developed.\nThis tool i now on its third generation, the two first generations can be found on the himConfigurator branch of this repo.\nThe current version of the tool is named the vspecPreprocessor. It supports the same features for tree modifications as the previous generation but now without requiring usage of the extended vspec format (vspec2). It is written in python, the himConfigurator was written in golang which often required separate installation of the build system.\nThe basis of the framework that can be used to define signal trees for different vehicle types is the HIM configurator. It works as a pre-processor that reads the extended vspec format, vspec2, and processes the extended instruction set described below from which it generates vspec formatted files which are applied as input to the VSS-tools exporters to generate fully configured trees for desired vehicle types and models.\nThe HIM configuration instructions are declared in JSON formatted files. These instructions can be applied to trees that have a pre-configured vehicle type specific structure, or that have a vehicle type agnostic structure. The VSS-core tree is an example of the latter, while the other trees in the Vehicle directory have a pre-configure vehicle type specific structure.\nA tree, whether it is vehicle type specific or not, shall be located on the spec/trees directory structure. These trees may then link to common objects which shall be located on the spec/objects directory structure. Vehicle specific trees can be derived from vehicle agnostic trees like the VSS-core tree without using the symlink mechanism.\nThe vision for this project is that vehicle specific trees will eventually be developed in separate Github projects that then will include the HIM configurator tool and a common vehicle agnostic tree as Github submodules or via other mechanisms, ths creating separate independent vehicle specific projects that are derived from a common signal source tree.\nHIM configurator The framework also contains a new tool, the HIM configurator. This tool is pre-processes vspec2 files to generate vspec files that are then used as input to the VSS-tools exporters. In its current version it provides support for the types of tree configuration that is described in the HIM extensions chapter below.\nHIM extensions The HIM syntax is in this project extended with the features described below. These can be preprocessed by the HIM configurator which transforms them into a HIM compliant format, thus making it possible to use the VSS-tools for exporting to other formats, including using overlays. When these extensions are used the file extension shall be \u0026ldquo;vspec2\u0026rdquo; instead of \u0026ldquo;vspec\u0026rdquo;. The rules for when the file extension \u0026ldquo;vspec2\u0026rdquo; shall be used instead of \u0026ldquo;vspec\u0026rdquo; are the following:\nA file that contains any extended syntax must be named with the file extension \u0026ldquo;vspec2\u0026rdquo; If a vspec2 file is referenced from within another file then this reference shall use the extension vspec if this file is located in the \u0026ldquo;trees\u0026rdquo; directory strucure. If a vspec2 file is referenced from within another file then this reference shall use the extension vspec2 if this file is located in the \u0026ldquo;objects\u0026rdquo; directory strucure. Extension 1: Instantiation configuration The HIM rule set supports the instantiation syntax inherited from VSS instantiation that can be used to request the VSS-tools to generate multiple instances of a branch/set of signals. This syntax has two options exemplified below\ninstances: [\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;] instances: Row[1,2] The examples above can be extended to two dimensions by using the array syntax, e.g. instances: - Row[1,2] - [\u0026#34;DriverSide\u0026#34;, \u0026#34;PassengerSide\u0026#34;] which will generate a structure with four branches - Row1:DriverSide, Row1:PassengerSide, Row2:DriverSide, Row2:PassengerSide. It is however not possible to use this syntax to express a configuration where for Row1 there are two child nodes, e.g. [\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;], and for Row2 there are three child nodes, e. g. [\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;Middle\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;].\nThis missing flexibility is however provided in the extended syntax supported by the HIM configurator. A two-dimensional instantiation is then expressed in the vspec file as:\ninstances0: x #instanceTag instances1: x #instanceTag where \u0026lsquo;instances0\u0026rsquo; is used for the \u0026lsquo;first-order\u0026rsquo; instantiation (Row[1,2] in the example above), and \u0026lsquo;instances1\u0026rsquo; is used for the \u0026lsquo;second-order\u0026rsquo; instantiation ([\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;] in the example above).\n\u0026lsquo;x\u0026rsquo; is a placeholder for the instance expression in the file himConfiguration.json that is the input to the HM configurator, and \u0026lsquo;instanceTag\u0026rsquo; is a unique name logically linking the two expressions, which must be preceded by a hash character (#). The two instance expressions can, but must not be on two subsequent rows. If not, then the second expression must be defined in any of the nodes that is part of the subtree under the node containing the first expression. The instance configuration input to the HIM configurator has a syntax as exemplified below.\n\u0026#34;instances\u0026#34;: { \u0026#34;Seat\u0026#34;: [ \u0026#34;Row[1,2]\u0026#34;, [ [ \u0026#34;DriverSide\u0026#34;, \u0026#34;PassengerSide\u0026#34; ], [ \u0026#34;DriverSide\u0026#34;, \u0026#34;Middle\u0026#34;, \u0026#34;PassengerSide\u0026#34; ] ] ] } The \u0026lsquo;Seat\u0026rsquo; shown above is the instanceTag name that the HIM configurator will try to match in the vspec file.\nThe \u0026lsquo;first-order\u0026rsquo; instantiation, in this case \u0026ldquo;Row[1,2]\u0026rdquo;, is followed by two \u0026lsquo;second-order\u0026rsquo; instantiation expressions.\nThe number of \u0026lsquo;second-order\u0026rsquo; expressions must match the number of instantiaions that the \u0026lsquo;first-order\u0026rsquo; expression will expand to.\nThe expressions can use any of the two syntax options mentioned above.\nCurrently this syntax can only be used for two-dimensional instantiations.\nExtension 2: Variability configuration The tree in vspec format may contain multiple variations of objects that in a deployment typically are not included. An example are the Combustion engine and the Electric engine. in an ICE vehicle the former should be included, but not the latter. For an EV vehicle it is vice versa. To enable one or the other of these objects to be included the following syntax is used, example taken from the Engine.vspec.\nVariationPoint: #EngineType - ICE #include CombustionEngine.yaml Engine - EV #include ElectricEngine.vspec Engine The keyword is VariationPoint, which on the same line must be followed by a hash sign (#) directly followe by a unique variation point tag (in this case EngineType. The value part of this key-value expression is an array of \u0026lsquo;variability object expressions\u0026rsquo;, where such an expression contains a \u0026lsquo;variability name\u0026rsquo; followed by an \u0026lsquo;#include expression\u0026rsquo;. This expression must be compliant with the syntax rules for HIM #include expressions. The array size is not restricted.\nThe input to the HIM configurator for it to resolve which variations to select is found in two files.\nThe Variability.json file, and the himConfiguration.json file. The Variability.json file defines the available variations, and which include statements that should be selected for the variation. As can be seen in th PHEV variation example below it is possible to select multiple include statements.\n\u0026#34;EngineType\u0026#34;: [ { \u0026#34;PHEV\u0026#34;: [ \u0026#34;ICE\u0026#34;, \u0026#34;EV\u0026#34; ] } The himConfiguration.json file contains the variation that that should be included in the tree that is generated by the himConfigurator (using a VSS-tools exporter), expressed by the rows below in this example:\n\u0026#34;variants\u0026#34;: { \u0026#34;EngineType\u0026#34;: \u0026#34;PHEV\u0026#34; Extension 3: Local variation point If an instantiation configuration has a need of including a variation point with different variants for the different intances then the Variation point feature described above cannot be used as it would apply the same variant to all instances. To meet this need the Local Variation point (LocalVP) is available. An expression like shown below is inserted in the subtree to be instantiated\nLocalVP: #AxleFeature - LIFTABLE #include Liftable.vspec Axle - STEERABLE #include Steerable.vspec Axle - DRIVING #include Driving.vspec Axle The himConfiguration.json file is then updated with the different configurations for the different instances as shown below.\n\u0026#34;variants\u0026#34;: { \u0026#34;AxleFeature.Row1\u0026#34;: \u0026#34;AXLE+STEER\u0026#34;, \u0026#34;AxleFeature.Row2\u0026#34;: \u0026#34;AXLE+LIFT\u0026#34;, \u0026#34;AxleFeature.Row3\u0026#34;: \u0026#34;AXLE+STEER+DRIVE\u0026#34; } As seen the AxlePoint local varation point name is extended with the names of the different instances Row1..Row3, which must be the same as the instantiation is configured with. The Variability.json shall then contain the definition of which include alternatives in the LocalVP command that shall be included.\n\u0026#34;AxleFeature\u0026#34;: [ { \u0026#34;AXLE\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;AXLE+LIFT\u0026#34;: \u0026#34;LIFTABLE\u0026#34; }, { \u0026#34;AXLE+STEER\u0026#34;: \u0026#34;STEERABLE\u0026#34; }, { \u0026#34;AXLE+DRIVE\u0026#34;: \u0026#34;DRIVING\u0026#34; }, { \u0026#34;AXLE+LIFT+STEER\u0026#34;: [ \u0026#34;LIFTABLE\u0026#34;, \u0026#34;STEERABLE\u0026#34; ] }, { \u0026#34;AXLE+LIFT+DRIVE\u0026#34;: [ \u0026#34;LIFTABLE\u0026#34;, \u0026#34;STEERABLE\u0026#34; ] }, { \u0026#34;AXLE+STEER+DRIVE\u0026#34;: [ \u0026#34;STEERABLE\u0026#34;, \u0026#34;DRIVING\u0026#34; ] }, { \u0026#34;AXLE+LIFT+STEER+DRIVE\u0026#34;: [ \u0026#34;LIFTABLE\u0026#34;, \u0026#34;STEERABLE\u0026#34;, \u0026#34;DRIVING\u0026#34; ] } ] With the above in place the HIM configurator will create the different variants for the different instances.\nExtension 4: Allowed datatype reference One of the information rule sets that HIM supports is the type definition rule set. A type definition tree is able to define structs and enums (allowed) that can be referenced from trees of other information types. Such a tree is defined in the spec/objects/Datatypes directory, currently containing the enums (allowed) that is used in the VSS tree. This tree has a structure that mirrors the structure from the VSS tree where the enums were originally used. This structure might later be changed to a more generic structuring to yield reference path names more decoupled from the VSS structure.\nAn external datatype reference to an enum (allowed) shall have a syntax as shown below.\ndatatype: Types.x.y.zValues where x, y, z may be names providing an understanding of the defined enum (allowed) that conform to the node HIM node name syntax. The name z must be postfixed with the tag Values.\nIf the HIM configurator is used to substitute external enum (Allowed) references it will create a Datatype.yaml file in the root directory of the signal tree that it is working on. The node type in a type definition tree shall be \u0026lsquo;property\u0026rsquo; but due to that the VSS-tools will reject separate trees with that node type, the node type \u0026lsquo;sensor\u0026rsquo; is used instead. This must therefore be manually edited to rename to \u0026lsquo;property\u0026rsquo; until a moodified version of VSS-tools is created, or that the HIM configurator is updated to handle the node type renaming.\nOverlays The HIM configurator supports invoking of overlays, which is then processed by the VSS-tools exporter. As it is fed to the VSS-tools overlay mechanism the syntax is identical. The path to the overlay files shall be added to the HIM configuration file as shown in the example below.\n\u0026#34;overlays\u0026#34;: [ \u0026#34;overlay/Truck/overlay1.vspec\u0026#34;, \u0026#34;overlay/Truck/overlay2.vspec\u0026#34; ] It is possible to disable the overlays by adding the CLI parameter -d, see Using the HIM Configurator. The file(s) generated by the VSS-tools exporter are saved in the spec/trees/exporterData directory.\nOverlays on instantiations The functionality provided by the Local Variation point extension, to be able to apply different configurations to the different instantiations, can also be realized using the overlays mechanism, but it requires some HIM configurator preprocessing. In the JSON input file to the HIM configurator the desired configurations are added associated with the \u0026ldquo;instance-overlays\u0026rdquo; key as shown in the example below.\n\u0026#34;instance-overlays\u0026#34;: { \u0026#34;Vehicle.Chassis.Axle.Row1\u0026#34;: \u0026#34;overlays/Truck/Steerable.vspec\u0026#34;, \u0026#34;Vehicle.Chassis.Axle.Row2\u0026#34;: \u0026#34;overlays/Truck/Liftable.vspec\u0026#34;, \u0026#34;Vehicle.Chassis.Axle.Row3\u0026#34;: \u0026#34;overlays/Truck/Steerable.vspec+overlays/Truck/Driving.vspec\u0026#34; } The key of an added key-value pair is the path to the branch node under which the configuration shoul be inserted, and the value is the path to the desired overlay file. If more than one overlaysfile is to be applied to the same path then they are separated by a plus sign (+) as shown for the Row3 in the example. The node names in this overlay file shall be \u0026ldquo;relative\u0026rdquo;, i. e. they shall not be complete path expressions, the HIM configurator will handle this by prepending them with the key value before applying it as input to the overlays mechanism in the VSS-tools. An example of a relaive overlays file is shown below.\nDriving: type: branch description: Axle driving features Driving.IsDiffLocked: datatype: boolean type: sensor description: True if differential is locked on the axle. These overlays files must be stored in the directories that is declared in the instance-overlays data. From the combined input mentioned above the HIM configurator will create temporary overlays files that are included in the call to the VSS-tools overlays mechanism. These files are automatically deleted after being used unless the -s or -p CLI parameter is used in the HIM configurator command.\nOverlays creator To support a scenario where a tree is to be built \u0026ldquo;from scratch\u0026rdquo; a tool named overlaysCreator has been developed. The assumption for the development of this tool was that at least parts of the tree will reuse existing and established structures. The tool will therefore take as input an existing tree in YAML format from which it will \u0026ldquo;pick\u0026rdquo; single leaf nodes, or subtrees, and write that into an overlays file. This overlays file can then be applied to any other tree, including an \u0026ldquo;empty tree\u0026rdquo; (a vspec file without any predefined nodes). An example scenario could be that a tree for a trailer should be built. The trailer tree should inherit the axle/wheel subtree structure from the VSS-core tree.\nThe first step would then be to create a him configuration file, e. g. named himConfig-trailer-base.json, that can configure the VSS-core tree with the desired axle/wheel layout, e. g. as shown below.\n{ \u0026#34;variants\u0026#34;: { \u0026#34;AxleFeature.Row1\u0026#34;: \u0026#34;AXLE+LIFT\u0026#34;, \u0026#34;AxleFeature.Row2\u0026#34;: \u0026#34;AXLE\u0026#34; }, \u0026#34;instances\u0026#34;: { \u0026#34;Axle\u0026#34;: [ \u0026#34;Row[1,2]\u0026#34;, [ [ \u0026#34;Pos6\u0026#34;, \u0026#34;Pos7\u0026#34;, \u0026#34;Pos9\u0026#34;, \u0026#34;Pos10\u0026#34; ], [ \u0026#34;Pos6\u0026#34;, \u0026#34;Pos7\u0026#34;, \u0026#34;Pos9\u0026#34;, \u0026#34;Pos10\u0026#34; ] ] ] } } This would then be used to create a YAML tree from the VSS-core.\n$ ./himConfigurator -r Vehicle/VSS-core/ -c himConfig-trailer-base.json Next the input file with instructions on which subtrees that should be picked from the created YAML tree is created, e. g. named himPickPaths.json and stored in the Vehicle/Empty directory.\n[ \u0026#34;Vehicle.VersionVSS\u0026#34;, \u0026#34;Vehicle.Chassis.Axle\u0026#34; ] With this pick file and the created YAML file as input, the overlays creator tool is called from the overlayscreator directory. The trailer tree is given the root node name Trailer by the -n Trailer CLI parameter. The go build command can be skipped if it is already built.\n$ cd overlayscreator $ go build $ ./overlaysCreator -r Vehicle/Empty/ -y ../exporterData/cvis.yaml -p himPickPaths.json -n Trailer -o overlay/overlayPick.vspec $ cd.. The final step is then to use the HIM configurator tool to build the trailer YAML tree from the Empty tree using the created overlays file. A HIM configuration file that instructs the tool to use it, e. g. named himConfig-trailer.json is created in the Vehicle/Empty directory.\n{ \u0026#34;overlays\u0026#34;: [ \u0026#34;overlay/overlayPick.vspec\u0026#34; ] } The HIM configurator is then used with the empty tree and the overlays file as input.\n$ ./himConfigurator -r Vehicle/Empty/ -c himConfig-trailer.json The YAML formatted trailer tree is now found as exporterData/cvis.yaml.\nTo populate the tree with more signals, create overlay files containing the wanted signal node data and then and add the paths to these overlay files to the overlay array in the himConfig-trailer.json file.\nTree development The HIM rule set for resource data is used to define signals in a tree. This syntax can be directly used as input to any of the exporter tools provided by VSS-tools.\nTrees under development Currently the following trees are under development:\nTruck tree Trailer tree Bus tree Driver tree VSS-core tree VSS-core2 tree The VSS-core tree is a vehicle type agnostic tree that is configured by the HIM configurator to become vehicle type specific. Configuration templates for the vehicle types Car and Truck are available, and can be used as starting poin to create templates for other vehicle types. This tree uses the variation point and local variation point extensions to realize vehicle specific trees.\nThe VSS-core2 tree is also a vehicle type agnostic tree that is configured by the HIM configurator to become vehicle type specific. However, the usage of the variation point and local variation point extensions is here replaced by usage of overlays. This alternative leads to less modifications of the VSS tree to create the VSS core tree.\nThe other trees are vehicle type specific from the start, or for Driver a supplementary tree to be used together with e. g. the Truck tree.\nSymbolic linking The directory structure for a single tree follows the VSS pattern with \u0026ldquo;#include\u0026rdquo; links in the vspec files that logically links to other files of the tree. However, to link to a file in the common objects structure the corresponding file in the trees structure is realized as a symbolic link file. This means that when the content of the file is accessed the underlying file system follows the symbolic link to the file in the objects structure for the actual content of the file. This is transparent to the entity accessing the file, so e. g. the exporter tools from VSS-tools will when used for a transformation of a specific tree access file content from the common objects files transparently.\nThe symbolic links used in a tree structure definition shall be declared in a script file that can be run to refresh the symlinks if a link is broken. The syntax of these script files differ between Linux and Windows, see the chapter below.\nLinux / Windows specific parts Symlink script files The symlink cript files used in Linux are standard bash script files, see e. g. cv-truck-symlinks.sh.\nFor Windows a Powershell script is used, see e. g. cv-truck-symlink.ps1 script in the Win-setup directory.\nVSS-tools activation The HIM configurator activates the VSS-tools exporter via a shell script. In Linux this is a Bash script, in Windows it is ealized by a Powershell script.\nInformation on how to install VSS-tools in Windows is found in the Win-setup directory.\nAlignment with other standards The terminology used in these HIM based specifications should try to align with terminology and principles from other standards. The cases that has been identified are described below.\nAxle and tire locations The ISO xxxx(number and link missing) specification includes a centerline based approach for commercial vehicles, see diagram below. The ISO naming conventions shown in the figure above can be realized by providing the configuration shown below as input to the HIM configurator, and inserting the \u0026ldquo;instances0/1\u0026rdquo; directives in the related vspec files.\n\u0026#34;instances\u0026#34;: { \u0026#34;Axle\u0026#34;: [ \u0026#34;Row[1,4]\u0026#34;, [ [\u0026#34;Pos7\u0026#34;,\u0026#34;Pos9\u0026#34;], [\u0026#34;Pos7\u0026#34;,\u0026#34;Pos9\u0026#34;], [\u0026#34;Pos6\u0026#34;,\u0026#34;Pos7\u0026#34;, \u0026#34;Pos9\u0026#34;,\u0026#34;Pos10\u0026#34;], [\u0026#34;Pos8\u0026#34;] ] ] } Further references, e.g. TMC VMRS, Fleet location codes, etc\u0026hellip;\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/tools/",
	"title": "CVIS Tools",
	"tags": [],
	"description": "",
	"content": "vspecPreprocessor The current version of the tool is documented in the vspecPreprocessor section.\nHIM configurator It is possible to find the complete framework of vspec2 trees, etc on the himConfigurator branch of this repo. The previous version is documented in the HIM Configurator section. Its docmentation is kept here as documentation only gets autogenerated n the main branch.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/trees/",
	"title": "CVIS vspec trees",
	"tags": [],
	"description": "",
	"content": "Tree development The HIM data rule set is used to define signals in a tree. This syntax can be directly used as input to any of the exporter tools provided by VSS-tools.\nVspec trees for different vehicle types, and also for other domains such e. g. Driver, are being developed. The root vspec file and other files needed as input to the VSS-tools exporters are for the different vehicle types found in respective directory under the spec/trees/Vehicle directory. Currently tree data for the following domains are represented:\nTruck tree Trailer tree Car tree Bus tree Driver tree Truck tree The truck tree is identical to the Car tree except for the Chassis.vspec file that is extended to include AxleFeature branches.\nTrailer tree The trailer tree directory includes two trees, one that represents a separate, standalone trailer tree, and another that represents a tree containing multiple trailers. The latter makes it possible to have one tree representing a train of one or more trailers.\nThe difference is found in the root vspec file of respective tree, the other vspec files in the subdirectories are the same.\nCar tree The car tree is identical to the VSS tree. It is included here to show how the vspecPreprocessor can be used to e. g. generate a ragged matrix for the configuration of seats with e. g. two seats in the first row and three in the second row.\nBus tree The bus tree is identical to the VSS tree. The vspecPreprocessor can e. g. be used to generate a bus specific seat layout.\nDriver tree The driver tree is yet to be populated. Currently is only contains empty branches to enable different data for EU and US legislation, respectively.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]