[
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/bus_tree/",
	"title": "Bus tree",
	"tags": [],
	"description": "",
	"content": "The bus tree The vspec bus tree is a super tree that contains signal definitions for a large set of different bus models. The HIM configurator is then used to create a signal tee for a specific bus variant.\nThe different bus variants that are present in the vspec files are:\nxxx "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/driver_tree/",
	"title": "Driver tree",
	"tags": [],
	"description": "",
	"content": "The Driver tree The vspec Driver tree \u0026hellip;.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/truck_tree/driver_tree/",
	"title": "Driver tree",
	"tags": [],
	"description": "",
	"content": "The driver tree The vspec driver tree is used to represent the truck driver data. The source for this driver data is the truck dirver recording unit (in europe often named tachograph, in the US xxx). As the driver recording unit may hold data not only for the current driver but also for previous drivers, there might be several instances of this driver tree, one for each driver that the driver recording unit has a record on. The data from these different instances should be accessible via the interface that is exposed by vehicle server managing the access to the driver recording device.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/examples/",
	"title": "Examples",
	"tags": [],
	"description": "",
	"content": "Examples of creating different vehicle type trees and how to use them in a client-server scenario Below is a list of examples of creating different vehicle type trees, and in some cases also how to use the trees in scenario with a client that over an interface access data represented in the tree.\nCreation of truck and trailer trees that are used in a client-server scenario using VISS as the interface "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/him_configurator/",
	"title": "HIM configurator",
	"tags": [],
	"description": "",
	"content": "HIM configurator Build instructions To build the HIM configurator it is necessary to first instal the Golang build system. Searching on \u0026ldquo;install golang\u0026rdquo; will lead to many matches of which one is:\nhttps://go.dev/doc/install\nTo build the HIM configurator, open a terminal and go to the spec/trees directory where the himConfigurator.go is stored, and issue the command\n$ go build -o himConfigurator\nInitializing the Python virtual environment The HIM configurator uses the VSS-tools exporters for the generation of the transformed vspec files. According to the instructions for this tool a Python virtual environment should be set up in which it then is run when exporting the vspec files to other formats. The work flow is to the first time initialize this environment, and then every time before running the HIM configurator activate the virtual environment, and when done terminate the virtual environment.\nIf the virtual environment has not been set up before on the computer, it could e. g. already has been used in a VSS context to transform vspec files, then the first time it needs to be created and configured. To create it issue the following command:\n$ python3 -m venv ~/.venv Then it needs to be configured for VSS-tools, which shall be done with the environment activated:\n$ source ~/.venv/bin/activate (.venv)$ pip install --pre vss-tools (.venv)$ deactivate The above is only needed to be done once. It might be necessary to install both python and pip if that is not already installed on the computer.\nTo then use the HIM configurator it is sufficient with activating the virtual environment before using the HIM configurator.\n$ source ~/.venv/bin/activate Then the HIM configurator can be run in the spec/trees directory with commands like:\n(.venv)$ ./himConfigurator -m binary -v Vehicle/Trailer/ Finally the environment shall be deactivated it after the use.\n(.venv)$ deactivate If the HIM configurator complains with error logs it may help to, one time, try the command:\n(.venv)$ pip install -e . A bash script file in the spec/trees directory, venv.sh, can be used instead of typing the commands manually in the terminal window. If this file is issued as shown below it responds with displaying the two supported usages.\n$ source venv.sh usage: source venv.sh startme|installme As shown it can either be used to install venv, which as described above is only needed to be run the very first time. The other alternative can thereafter be used to activate venv.\nUsing the HIM configurator Starting the HIM configurator with the command:\n(.venv)$ ./himConfigurator -h\nwill show the command line options that is possible to apply at startup.\nusage: print [-h|--help] [-m|--makecommand (all|yaml|json|csv|binary)] [-c|--configfile \u0026#34;\u0026lt;value\u0026gt;\u0026#34;] [-r|--rootdir \u0026#34;\u0026lt;value\u0026gt;\u0026#34;] [-s|--vspecsave] [-p|--preprocess] [-n|--noEnumSubst] [-d|--disableOverlays] [-t|--typefile \u0026#34;\u0026lt;value\u0026gt;\u0026#34;] HIM configurator Arguments: -h --help Print help information -m --makecommand Make command parameter must be either: all, yaml, json, csv, or binary. Default: yaml -c --configfile configuration file name. Default: himConfig-truck.json -r --rootdir path to vspec root directory. Default: Vehicle/VSS-core/ -s --vspecsave Saves the configured .vspec2 files with extension .vspec -p --preprocess Pre-process only, save configured vspec files. Do not run VSS-tools. -n --noEnumSubst No substitution of enum links to Datatype tree with actual datatypes -d --disableOverlays Disables VSS-tools overlay configurations -t --typefile type definition file name The -m command line option is used to set which VSS-tools exporter the configured tree should have. The value \u0026lsquo;all\u0026rsquo; leads to that all the exporters that are compatible with the HIM configurator are executed. If not used the default is \u0026lsquo;yaml\u0026rsquo;.\nThe -c command line option is used to select the HIM configurator file. This is useful when a tree has multiple configuration files. Default is himConfig-truck.json.\nThe -r command line option is used to set the path to the tree that should be used as input for the configuration. The path is relative to the tree directory, and should have the slash \u0026lsquo;/\u0026rsquo; character at the end of the path. If not used the default is \u0026lsquo;Vehicle/VSS-core/\u0026rsquo;.\nIf the -s command line option is set the the HIM configurator does not delete the vspec files that it generates from the vspec2 files that are found in the tree structure. If not set these vspec files are deleted after being used as input to the call of the VSS-tools exporter(s). If not used the default is false, i. e. not to save the files.\nWith the vspec files saved it becomes possible to run the VSS-tols exporters \u0026ldquo;manually\u0026rdquo; with the vspec root node as input. This might be helpful if the development environment is not a Linux compatible environment, or if there is a need to debug the VSS-tools processing, se below.\nThe -p command line option leads to that the HIM configurator does not issue a command to the VSS-tools exporters. The vspec files generated by the HIM configurator is saved, and the VSS-tools exporters can be activated \u0026ldquo;manually\u0026rdquo; with the pre-processed tree as input.\nThe -n command line option is used if substitution is not desired of the external datatype references with the actual enum definitions from the common Datatypes tree in the generated tree(s). However, VSS-tools currently does not accept the syntax using a reference.\nThe -d command line option is used to disable the overlays to be invoked to the VSS-tools exporter.\nThe -t command line option is used to include a type definition tree in the CLI to theVSS-tools. If the main tree includes a struct then its datatype shall be a path pointing to the struct in the type definition tree. VSS-tools then require that the type definition tree is available to verify the path.\nVSS-tools debug \u0026lsquo;in the development of the trees it might happen that errors are introduced in the vspec2/vspec files. There is some logging information saved in the spec/trees/exporterData/exporterLog.txt. The first line in that file shows the command that is issued to the VSS-tools vspec service. This can be copied and then issued manaually in a terminal window, in which case the more comprehensive error logging by the VSS-tools exporter will be available. However, for it to work the HIM configurator must have saved the vspec files by adding the -p CLI parameter to the HIM configurator command.\nCreation of a vehicle variant specific signal tree The HIM configurator enables a model where a \u0026ldquo;super tree\u0026rdquo; covering all variations that a vehicle may be equipped with, e. g. propulsion technology like ICE, PHEV, EV, etc. can be defined in the vspec files, then the HIM configurator can be used to create a \u0026ldquo;variant specific\u0026rdquo; vehicle signal tree from the variation point configuration in the himConfiguration.json file.\nUsage of a vehicle variant specific signal tree The output from the HIM configurator is the selected parts of the \u0026ldquo;vspec super tree\u0026rdquo; in a file with one of the supported formats. This file can then e. g. be used in a vehicle of the selected variant by a server that is managing the access to the signals. The server can then use the tree to \u0026ldquo;vet\u0026rdquo; client request - checking that the signal is present, whether it is read-only or read-write, that credentials are valid if access control is applied, etc. An example of a server using it like this is the VISS reference server.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/trailer_tree/",
	"title": "Trailer tree",
	"tags": [],
	"description": "",
	"content": "The trailer tree The vspec trailer tree is a super tree that contains signal definitions for a large set of different trailer models. The HIM configurator is then used to create a signal tee for a specific trailer variant.\nThe different variants that are present in the vspec files are:\nFlatbed trailer: This trailer type has an open flat bed cargo unit. Box trailer: This trailer type has a cargo unit that is covered by walls and a roof. Tanker trailer: This trailer type has a cargo unit that is specicialized for carrying liquid cargos. Freezer trailer: This trailer type has a cargo unit that is specicialized for carrying cargos that require cooling. Specialized trailer: This trailer type has a cargo unit that does not match with any of the other types\u0026hellip; "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/examples/truck_trailer_viss/",
	"title": "Truck and trailer trees used in VISS access scenario",
	"tags": [],
	"description": "",
	"content": "Creation of truck and trailer trees that are used in a client-server scenario using VISS as the interface The following describes how a demo can be set up in which a client can read and write signals from a truck and a trailer that is connected to it using the VISS interface.\nThe two repos that are needed for this are the CVIS and the VISSR repos, so start with cloning these if not done earlier.\n$ git clone https://github.com/COVESA/commercial-vehicle-information-specifications.git\n$ git clone https://github.com/COVESA/vissr.git\nThe database that VISSR is configured to use must be installed on the computer. Redis is the default configuration.\nPlease see the docmentation of respective database for how to install if that is needed.\nNext step is to use the HIM configurator to create the truck and trailer trees. The HIM configurator must then first be built which the following command ,issued in the CVIS/spec/trees directory.\n$ go build -o himConfigurator\nFor the above to succeed the Golang build system must have been installed, which is described here.\nThe HIM configurator calls the VSS-tools exporter after its initial preprocessing of vspec2 files. To set up the environment required by the VSS-tools exporter the Python virtual environment, venv, must be activated. This is done by the following command.\n$ source venv.sh startme\nVenv can when not needed anymore be deactivated by the command:\n(.venv)$ deactivate\nThe existing vspec trees that are found in the CVIS/spec/trees/Vehicle/VSS-core2 and CVIS/spec/trees/Vehicle/Trailer directories will be used. These trees are not yet complete signal reprensentations for trucks and trailers but as it is what we have available at this point let us use them. The HIM configurator tool will generate binary format representations of the two trees by invoking it as shown below. If a human readable YAML version is desired, remove the \u0026lsquo;-m binary\u0026rsquo; from the commands or replace it with \u0026lsquo;-m yaml\u0026rsquo;.\nTo generate the trailer tree:\n$ ./himConfigurator -c himConfiguration.json -r Vehicle/Trailer/ -m binary\nThe binary tree is then found in CVIS/spec/trees/exporterData with the file name cvis.binary. Rename this file to Trailer.binary.\nTo generate the truck tree:\n$ ./himConfigurator -c himConfig-truck.json -r Vehicle/VSS-core2/ -m binary\nThe binary tree is then found in CVIS/spec/trees/exporterData with the file name cvis.binary. Rename this file to Truck.binary.\nThe binary format is the format that the VISSR server expects the trees to have. The directory VISSR/server/vissv2server/forest is the local repository for trees so copy the two files Truck.binary and Trailer.binary there. $ cp /CVIS/spec/trees/exporterData/Truck.binary /VISSR/server/vissv2server/forest/Truck.binary\n$ cp /CVIS/spec/trees/exporterData/Trailer.binary /VISSR/server/vissv2server/forest/Trailer.binary\nis to be replaced with the path on your device to the VISSR and CVIS root directories.\nIf you for some reason failed in creating the binary trees using the HIM configurator there are copies available in the CVIS/demodata directory.\nFor the VISSR server to register the binary trees at startup the file VISSR/server/vissv2server/viss.him must be modified to contain the information for these trees. The file CVIS/demodata/viss.him is configured or this, so it can be copied to the VISSR/server/vissv2server directory. If you do not want the viss.him file that is in this directory to be overwritten it needs to be renamed before the copy operation.\nTo enable a demo where a client can access dynamically changing signal values the feeder needs to be configured for this. The feder implementation in vissr/feeder/feeder-template/feederv3 can be started with a CLI parameter \u0026ldquo;-i truck-trailer-sim.json\u0026rdquo; where the file truck-trailer-sim.json contains the simulated signal data. More about configuring the simulation can be found here. A minimal simulation file truck-trailer-sim.json is available in the CVIS/demodata directory. This file can easily be extended with more signals and more samples per signal. Copy that file to vissr/feeder/feeder-template/feederv3.\nTo start the VISSR server and feeder copy the bash shell file CVIS/demodata/runtrucktrailer.sh to the VISSR directory. The command below will then start them using the mentioned simulator input to the feeder.\n$ ./runtrucktrailer.sh startme\nWhat is needed now is a client that can be used to issue requests for truck or trailer signals to the server. Teh VISSR repo has a number of clients in the VISSR/client/client-1.0 directories that can be used, either as is or as a code template to be modified.\nThe VISSR/client/client-1.0/Javascript/wsclient.html that uses the Websocket protocol can be used directly, by clicking on the file it will open in the browser. Start to enter the IP address of the server into the uppermost field and click on the Server IP button. If the server has the same IP address as this client then \u0026ldquo;localhost\u0026rdquo; can be written into the field instead.\nNow request messages can be copied into the field below followed by clicking on the Send button and the responses from the server will be shown below in the browser tab. Below is shown a few requests that can be used.\n{\u0026#34;action\u0026#34;:\u0026#34;get\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;Vehicle.TraveledDistance\u0026#34;,\u0026#34;requestId\u0026#34;:\u0026#34;232\u0026#34;} {\u0026#34;action\u0026#34;:\u0026#34;get\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;Vehicle.CurrentLocation\u0026#34;,\u0026#34;filter\u0026#34;:{\u0026#34;variant\u0026#34;:\u0026#34;paths\u0026#34;,\u0026#34;parameter\u0026#34;:[\u0026#34;Longitude\u0026#34;,\u0026#34;Latitude\u0026#34;]},\u0026#34;requestId\u0026#34;:\u0026#34;237\u0026#34;} {\u0026#34;action\u0026#34;:\u0026#34;subscribe\u0026#34;,\u0026#34;path\u0026#34;:\u0026#34;Trailer1.Chassis.Axle.Row1.Wheel.Pos7.Tire.Temperature\u0026#34;,\u0026#34;filter\u0026#34;:{\u0026#34;variant\u0026#34;:\u0026#34;timebased\u0026#34;,\u0026#34;parameter\u0026#34;:{\u0026#34;period\u0026#34;:\u0026#34;1000\u0026#34;}},\u0026#34;requestId\u0026#34;:\u0026#34;246\u0026#34;} {\u0026#34;action\u0026#34;:\u0026#34;unsubscribe\u0026#34;,\u0026#34;subscriptionId\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;requestId\u0026#34;:\u0026#34;240\u0026#34;} Other websocket request examples can be found in VISSR/client/client-1.0/Javascript/appclient_commands.txt that can be modified to signal paths used in this demo.\nTo simulate that one more trailer is towed by the truck the steps below can be followed.\nIssue a command to stop the server and feeder:\n$ ./runtrucktrailer.sh stopme\nAdd one more trailer tree. This can be done by first creating another trailer binary tree using the HIM configurator, but a shortcut is possible by using the same binary tree as for the first trailer. To do this add the following rows to the viss.him file:\nHIM.Trailer2: type: direct domain: Automotive.Trailer.Data version: 0.1.0 local: forest/Trailer.binary public: https://github.com/COVESA/commercial-vehicle-information-specifications/tree/main/spec/trees/Vehicle/Trailer description: A tree for the second trailer in the train. The snippet above can be inserted at the top or at the bottom, or in between any two tree declarations.\nTo get back any values from get requests to Trailer2 the truck-trailer-sim.json file needs to be updated with that.\nThen restart the server and feeder:\n$ ./runtrucktrailer.sh startme\nSignal data from the new trailer can now be accessed using requests with paths having Trailer2 as the root node name (the first segment name in the path).\nThe VISSR server supports \u0026lsquo;forest inquiry\u0026rsquo; requests as shown below. This is not part of the VISSv3.0 spec but may become part of a next version.\n{\u0026#34;action\u0026#34;:\u0026#34;get\u0026#34;, \u0026#34;path\u0026#34;:\u0026#34;HIM\u0026#34;, \u0026#34;filter\u0026#34;:{\u0026#34;variant\u0026#34;:\u0026#34;metadata\u0026#34;, \u0026#34;parameter\u0026#34;:\u0026#34;0\u0026#34;}, \u0026#34;requestId\u0026#34;:\u0026#34;1957\u0026#34;} The response will contain the metadata from the viss.him file in JSON format, except the \u0026rsquo;local\u0026rsquo; property that is excluded as it is server internal data.\nThe browser tab rendered by wsclient.html may look something like below, depending on which requests that have been issued to the server. "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/truck_tree/",
	"title": "Truck tree",
	"tags": [],
	"description": "",
	"content": "The truck tree The vspec truck tree is a super tree that contains signal definitions for a large set of different truck models. The HIM configurator is then used to create a signal tee for a specific truck variant.\nThe different variants that are present in the vspec files are:\nTow truck: This truck type does not have an integrated cargo unit, but instead it is temporarily connected to a trailer (which defines its own signal tree). Flatbed truck: This truck type has an open flat bed cargo unit that is integrated with the rest of the truck. Box truck: This truck type has a cargo unit that is covered by walls and a roof that is integrated with the rest of the truck. Pickup truck: The model would support pickup trucks to be defined here also\u0026hellip; Van: The model would support vans to be defined here also\u0026hellip; "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/vss-core_tree/",
	"title": "VSS-core tree",
	"tags": [],
	"description": "",
	"content": "The VSS-core tree The VSS-core tree is a vehicle type agnostic tree that supports the generation of vehicle type specific trees by usage of the HIM configurator. The HIM configurator is then instructed to read input from vehicle specific configuration files. This concept is in theory applicable to any vehicle type that shares at least some basic concepts with other vehicle types. Vehicle types that are likely to be able to use this concept are e. g.:\nCar Truck Bus Van Pick-up It may also be useful for vehicle types like:\nTrailer Motorcycle For vehicle types that only share a small amount of basic concepts with other vehicle types the model that is also present in the CVIS project, a structure with common objects that can be shared may be a better fit.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/",
	"title": "Commercial Vehicle Information Specifications",
	"tags": [],
	"description": "",
	"content": "Commercial Vehicle Information Specifications Overview The ambition of the CVIS project is to develop a framework that can be used to define signal trees for different vehicle types, and then to use this framework to develop signal trees for vehicle types as e. g. Trucks, Trailers, Buses, and Passenger cars. The trees for these vehicle types shall share as much as possible of signals that can be commonly defined. The basis for common signals shall be the VSS tree. This tree has a focus on signals for passenger cars, but a significant part of these can very well be shared with the other vehicle types.\nThe CVIS project uses the Resource profile of the Hierarchical Information Model [HIM), which is fully compatible with the VSS rule set.\nThe basis of the framework that can be used to define signal trees for different vehicle types is the HIM configurator. It works as a pre-processor that reads the extended vspec format, vspec2, and processes the extended instruction set described below from which it generates vspec formatted files which are applied as input to the VSS-tools exporters to generate fully configured trees for desired vehicle types and models.\nThe HIM configuration instructions are declared in JSON formatted files. These instructions can be applied to trees that have a pre-configured vehicle type specific structure, or that have a vehicle type agnostic structure. The VSS-core tree is an example of the latter, while the other trees in the Vehicle directory have a pre-configure vehicle type specific structure.\nA tree, whether it is vehicle type specific or not, shall be located on the spec/trees directory structure. These trees may then link to common objects which shall be located on the spec/objects directory structure. Vehicle specific trees can be derived from vehicle agnostic trees like the VSS-core tree without using the symlink mechanism.\nThe vision for this project is that vehicle specific trees will eventually be developed in separate Github projects that then will include the HIM configurator tool and a common vehicle agnostic tree as Github submodules or via other mechanisms, ths creating separate independent vehicle specific projects that are derived from a common signal source tree.\nHIM configurator The framework also contains a new tool, the HIM configurator. This tool is pre-processes vspec2 files to generate vspec files that are then used as input to the VSS-tools exporters. In its current version it provides support for the types of tree configuration that is described in the HIM extensions chapter below.\nHIM extensions The HIM syntax is in this project extended with the features described below. These can be preprocessed by the HIM configurator which transforms them into a HIM compliant format, thus making it possible to use the VSS-tools for exporting to other formats, including using overlays. When these extensions are used the file extension shall be \u0026ldquo;vspec2\u0026rdquo; instead of \u0026ldquo;vspec\u0026rdquo;. The rules for when the file extension \u0026ldquo;vspec2\u0026rdquo; shall be used instead of \u0026ldquo;vspec\u0026rdquo; are the following:\nA file that contains any extended syntax must be named with the file extension \u0026ldquo;vspec2\u0026rdquo; If a vspec2 file is referenced from within another file then this reference shall use the extension vspec if this file is located in the \u0026ldquo;trees\u0026rdquo; directory strucure. If a vspec2 file is referenced from within another file then this reference shall use the extension vspec2 if this file is located in the \u0026ldquo;objects\u0026rdquo; directory strucure. Extension 1: Instantiation configuration The HIM rule set supports the instantiation syntax inherited from VSS instantiation that can be used to request the VSS-tools to generate multiple instances of a branch/set of signals. This syntax has two options exemplified below\ninstances: [\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;] instances: Row[1,2] The examples above can be extended to two dimensions by using the array syntax, e.g. instances: - Row[1,2] - [\u0026#34;DriverSide\u0026#34;, \u0026#34;PassengerSide\u0026#34;] which will generate a structure with four branches - Row1:DriverSide, Row1:PassengerSide, Row2:DriverSide, Row2:PassengerSide. It is however not possible to use this syntax to express a configuration where for Row1 there are two child nodes, e.g. [\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;], and for Row2 there are three child nodes, e. g. [\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;Middle\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;].\nThis missing flexibility is however provided in the extended syntax supported by the HIM configurator. A two-dimensional instantiation is then expressed in the vspec file as:\ninstances0: x #instanceTag instances1: x #instanceTag where \u0026lsquo;instances0\u0026rsquo; is used for the \u0026lsquo;first-order\u0026rsquo; instantiation (Row[1,2] in the example above), and \u0026lsquo;instances1\u0026rsquo; is used for the \u0026lsquo;second-order\u0026rsquo; instantiation ([\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;] in the example above).\n\u0026lsquo;x\u0026rsquo; is a placeholder for the instance expression in the file himConfiguration.json that is the input to the HM configurator, and \u0026lsquo;instanceTag\u0026rsquo; is a unique name logically linking the two expressions, which must be preceded by a hash character (#). The two instance expressions can, but must not be on two subsequent rows. If not, then the second expression must be defined in any of the nodes that is part of the subtree under the node containing the first expression. The instance configuration input to the HIM configurator has a syntax as exemplified below.\n\u0026#34;instances\u0026#34;: { \u0026#34;Seat\u0026#34;: [ \u0026#34;Row[1,2]\u0026#34;, [ [ \u0026#34;DriverSide\u0026#34;, \u0026#34;PassengerSide\u0026#34; ], [ \u0026#34;DriverSide\u0026#34;, \u0026#34;Middle\u0026#34;, \u0026#34;PassengerSide\u0026#34; ] ] ] } The \u0026lsquo;Seat\u0026rsquo; shown above is the instanceTag name that the HIM configurator will try to match in the vspec file.\nThe \u0026lsquo;first-order\u0026rsquo; instantiation, in this case \u0026ldquo;Row[1,2]\u0026rdquo;, is followed by two \u0026lsquo;second-order\u0026rsquo; instantiation expressions.\nThe number of \u0026lsquo;second-order\u0026rsquo; expressions must match the number of instantiaions that the \u0026lsquo;first-order\u0026rsquo; expression will expand to.\nThe expressions can use any of the two syntax options mentioned above.\nCurrently this syntax can only be used for two-dimensional instantiations.\nExtension 2: Variability configuration The tree in vspec format may contain multiple variations of objects that in a deployment typically are not included. An example are the Combustion engine and the Electric engine. in an ICE vehicle the former should be included, but not the latter. For an EV vehicle it is vice versa. To enable one or the other of these objects to be included the following syntax is used, example taken from the Engine.vspec.\nVariationPoint: #EngineType - ICE #include CombustionEngine.yaml Engine - EV #include ElectricEngine.vspec Engine The keyword is VariationPoint, which on the same line must be followed by a hash sign (#) directly followe by a unique variation point tag (in this case EngineType. The value part of this key-value expression is an array of \u0026lsquo;variability object expressions\u0026rsquo;, where such an expression contains a \u0026lsquo;variability name\u0026rsquo; followed by an \u0026lsquo;#include expression\u0026rsquo;. This expression must be compliant with the syntax rules for HIM #include expressions. The array size is not restricted.\nThe input to the HIM configurator for it to resolve which variations to select is found in two files.\nThe Variability.json file, and the himConfiguration.json file. The Variability.json file defines the available variations, and which include statements that should be selected for the variation. As can be seen in th PHEV variation example below it is possible to select multiple include statements.\n\u0026#34;EngineType\u0026#34;: [ { \u0026#34;PHEV\u0026#34;: [ \u0026#34;ICE\u0026#34;, \u0026#34;EV\u0026#34; ] } The himConfiguration.json file contains the variation that that should be included in the tree that is generated by the himConfigurator (using a VSS-tools exporter), expressed by the rows below in this example:\n\u0026#34;variants\u0026#34;: { \u0026#34;EngineType\u0026#34;: \u0026#34;PHEV\u0026#34; Extension 3: Local variation point If an instantiation configuration has a need of including a variation point with different variants for the different intances then the Variation point feature described above cannot be used as it would apply the same variant to all instances. To meet this need the Local Variation point (LocalVP) is available. An expression like shown below is inserted in the subtree to be instantiated\nLocalVP: #AxleFeature - LIFTABLE #include Liftable.vspec Axle - STEERABLE #include Steerable.vspec Axle - DRIVING #include Driving.vspec Axle The himConfiguration.json file is then updated with the different configurations for the different instances as shown below.\n\u0026#34;variants\u0026#34;: { \u0026#34;AxleFeature.Row1\u0026#34;: \u0026#34;AXLE+STEER\u0026#34;, \u0026#34;AxleFeature.Row2\u0026#34;: \u0026#34;AXLE+LIFT\u0026#34;, \u0026#34;AxleFeature.Row3\u0026#34;: \u0026#34;AXLE+STEER+DRIVE\u0026#34; } As seen the AxlePoint local varation point name is extended with the names of the different instances Row1..Row3, which must be the same as the instantiation is configured with. The Variability.json shall then contain the definition of which include alternatives in the LocalVP command that shall be included.\n\u0026#34;AxleFeature\u0026#34;: [ { \u0026#34;AXLE\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;AXLE+LIFT\u0026#34;: \u0026#34;LIFTABLE\u0026#34; }, { \u0026#34;AXLE+STEER\u0026#34;: \u0026#34;STEERABLE\u0026#34; }, { \u0026#34;AXLE+DRIVE\u0026#34;: \u0026#34;DRIVING\u0026#34; }, { \u0026#34;AXLE+LIFT+STEER\u0026#34;: [ \u0026#34;LIFTABLE\u0026#34;, \u0026#34;STEERABLE\u0026#34; ] }, { \u0026#34;AXLE+LIFT+DRIVE\u0026#34;: [ \u0026#34;LIFTABLE\u0026#34;, \u0026#34;STEERABLE\u0026#34; ] }, { \u0026#34;AXLE+STEER+DRIVE\u0026#34;: [ \u0026#34;STEERABLE\u0026#34;, \u0026#34;DRIVING\u0026#34; ] }, { \u0026#34;AXLE+LIFT+STEER+DRIVE\u0026#34;: [ \u0026#34;LIFTABLE\u0026#34;, \u0026#34;STEERABLE\u0026#34;, \u0026#34;DRIVING\u0026#34; ] } ] With the above in place the HIM configurator will create the different variants for the different instances.\nExtension 4: Allowed datatype reference One of the information rule sets that HIM supports is the type definition rule set. A type definition tree is able to define structs and enums (allowed) that can be referenced from trees of other information types. Such a tree is defined in the spec/objects/Datatypes directory, currently containing the enums (allowed) that is used in the VSS tree. This tree has a structure that mirrors the structure from the VSS tree where the enums were originally used. This structure might later be changed to a more generic structuring to yield reference path names more decoupled from the VSS structure.\nAn external datatype reference to an enum (allowed) shall have a syntax as shown below.\ndatatype: Types.x.y.zValues where x, y, z may be names providing an understanding of the defined enum (allowed) that conform to the node HIM node name syntax. The name z must be postfixed with the tag Values.\nIf the HIM configurator is used to substitute external enum (Allowed) references it will create a Datatype.yaml file in the root directory of the signal tree that it is working on. The node type in a type definition tree shall be \u0026lsquo;property\u0026rsquo; but due to that the VSS-tools will reject separate trees with that node type, the node type \u0026lsquo;sensor\u0026rsquo; is used instead. This must therefore be manually edited to rename to \u0026lsquo;property\u0026rsquo; until a moodified version of VSS-tools is created, or that the HIM configurator is updated to handle the node type renaming.\nOverlays The HIM configurator supports invoking of overlays, which is then processed by the VSS-tools exporter. As it is fed to the VSS-tools overlay mechanism the syntax is identical. The path to the overlay files shall be added to the HIM configuration file as shown in the example below.\n\u0026#34;overlays\u0026#34;: [ \u0026#34;overlay/Truck/overlay1.vspec\u0026#34;, \u0026#34;overlay/Truck/overlay2.vspec\u0026#34; ] It is possible to disable the overlays by adding the CLI parameter -d, see Using the HIM Configurator. The file(s) generated by the VSS-tools exporter are saved in the spec/trees/exporterData directory.\nOverlays on instantiations The functionality provided by the Local Variation point extension, to be able to apply different configurations to the different instantiations, can also be realized using the overlays mechanism, but it requires some HIM configurator preprocessing. In the JSON input file to the HIM configurator the desired configurations are added associated with the \u0026ldquo;instance-overlays\u0026rdquo; key as shown in the example below.\n\u0026#34;instance-overlays\u0026#34;: { \u0026#34;Vehicle.Chassis.Axle.Row1\u0026#34;: \u0026#34;overlays/Truck/Steerable.vspec\u0026#34;, \u0026#34;Vehicle.Chassis.Axle.Row2\u0026#34;: \u0026#34;overlays/Truck/Liftable.vspec\u0026#34;, \u0026#34;Vehicle.Chassis.Axle.Row3\u0026#34;: \u0026#34;overlays/Truck/Steerable.vspec+overlays/Truck/Driving.vspec\u0026#34; } The key of an added key-value pair is the path to the branch node under which the configuration shoul be inserted, and the value is the path to the desired overlay file. If more than one overlaysfile is to be applied to the same path then they are separated by a plus sign (+) as shown for the Row3 in the example. The node names in this overlay file shall be \u0026ldquo;relative\u0026rdquo;, i. e. they shall not be complete path expressions, the HIM configurator will handle this by prepending them with the key value before applying it as input to the overlays mechanism in the VSS-tools. An example of a relaive overlays file is shown below.\nDriving: type: branch description: Axle driving features Driving.IsDiffLocked: datatype: boolean type: sensor description: True if differential is locked on the axle. These overlays files must be stored in the directories that is declared in the instance-overlays data. From the combined input mentioned above the HIM configurator will create temporary overlays files that are included in the call to the VSS-tools overlays mechanism. These files are automatically deleted after being used unless the -s or -p CLI parameter is used in the HIM configurator command.\nOverlays creator To support a scenario where a tree is to be built \u0026ldquo;from scratch\u0026rdquo; a tool named overlaysCreator has been developed. The assumption for the development of this tool was that at least parts of the tree will reuse existing and established structures. The tool will therefore take as input an existing tree in YAML format from which it will \u0026ldquo;pick\u0026rdquo; single leaf nodes, or subtrees, and write that into an overlays file. This overlays file can then be applied to any other tree, including an \u0026ldquo;empty tree\u0026rdquo; (a vspec file without any predefined nodes). An example scenario could be that a tree for a trailer should be built. The trailer tree should inherit the axle/wheel subtree structure from the VSS-core tree.\nThe first step would then be to create a him configuration file, e. g. named himConfig-trailer-base.json, that can configure the VSS-core tree with the desired axle/wheel layout, e. g. as shown below.\n{ \u0026#34;variants\u0026#34;: { \u0026#34;AxleFeature.Row1\u0026#34;: \u0026#34;AXLE+LIFT\u0026#34;, \u0026#34;AxleFeature.Row2\u0026#34;: \u0026#34;AXLE\u0026#34; }, \u0026#34;instances\u0026#34;: { \u0026#34;Axle\u0026#34;: [ \u0026#34;Row[1,2]\u0026#34;, [ [ \u0026#34;Pos6\u0026#34;, \u0026#34;Pos7\u0026#34;, \u0026#34;Pos9\u0026#34;, \u0026#34;Pos10\u0026#34; ], [ \u0026#34;Pos6\u0026#34;, \u0026#34;Pos7\u0026#34;, \u0026#34;Pos9\u0026#34;, \u0026#34;Pos10\u0026#34; ] ] ] } } This would then be used to create a YAML tree from the VSS-core.\n$ ./himConfigurator -r Vehicle/VSS-core/ -c himConfig-trailer-base.json Next the input file with instructions on which subtrees that should be picked from the created YAML tree is created, e. g. named himPickPaths.json and stored in the Vehicle/Empty directory.\n[ \u0026#34;Vehicle.VersionVSS\u0026#34;, \u0026#34;Vehicle.Chassis.Axle\u0026#34; ] With this pick file and the created YAML file as input, the overlays creator tool is called from the overlayscreator directory. The trailer tree is given the root node name Trailer by the -n Trailer CLI parameter. The go build command can be skipped if it is already built.\n$ cd overlayscreator $ go build $ ./overlaysCreator -r Vehicle/Empty/ -y ../exporterData/cvis.yaml -p himPickPaths.json -n Trailer -o overlay/overlayPick.vspec $ cd.. The final step is then to use the HIM configurator tool to build the trailer YAML tree from the Empty tree using the created overlays file. A HIM configuration file that instructs the tool to use it, e. g. named himConfig-trailer.json is created in the Vehicle/Empty directory.\n{ \u0026#34;overlays\u0026#34;: [ \u0026#34;overlay/overlayPick.vspec\u0026#34; ] } The HIM configurator is then used with the empty tree and the overlays file as input.\n$ ./himConfigurator -r Vehicle/Empty/ -c himConfig-trailer.json The YAML formatted trailer tree is now found as exporterData/cvis.yaml.\nTo populate the tree with more signals, create overlay files containing the wanted signal node data and then and add the paths to these overlay files to the overlay array in the himConfig-trailer.json file.\nTree development The HIM rule set for resource data is used to define signals in a tree. This syntax can be directly used as input to any of the exporter tools provided by VSS-tools.\nTrees under development Currently the following trees are under development:\nTruck tree Trailer tree Bus tree Driver tree VSS-core tree VSS-core2 tree The VSS-core tree is a vehicle type agnostic tree that is configured by the HIM configurator to become vehicle type specific. Configuration templates for the vehicle types Car and Truck are available, and can be used as starting poin to create templates for other vehicle types. This tree uses the variation point and local variation point extensions to realize vehicle specific trees.\nThe VSS-core2 tree is also a vehicle type agnostic tree that is configured by the HIM configurator to become vehicle type specific. However, the usage of the variation point and local variation point extensions is here replaced by usage of overlays. This alternative leads to less modifications of the VSS tree to create the VSS core tree.\nThe other trees are vehicle type specific from the start, or for Driver a supplementary tree to be used together with e. g. the Truck tree.\nSymbolic linking The directory structure for a single tree follows the VSS pattern with \u0026ldquo;#include\u0026rdquo; links in the vspec files that logically links to other files of the tree. However, to link to a file in the common objects structure the corresponding file in the trees structure is realized as a symbolic link file. This means that when the content of the file is accessed the underlying file system follows the symbolic link to the file in the objects structure for the actual content of the file. This is transparent to the entity accessing the file, so e. g. the exporter tools from VSS-tools will when used for a transformation of a specific tree access file content from the common objects files transparently.\nThe symbolic links used in a tree structure definition shall be declared in a script file that can be run to refresh the symlinks if a link is broken. The syntax of these script files differ between Linux and Windows, see the chapter below.\nLinux / Windows specific parts Symlink script files The symlink cript files used in Linux are standard bash script files, see e. g. cv-truck-symlinks.sh.\nFor Windows a Powershell script is used, see e. g. cv-truck-symlink.ps1 script in the Win-setup directory.\nVSS-tools activation The HIM configurator activates the VSS-tools exporter via a shell script. In Linux this is a Bash script, in Windows it is ealized by a Powershell script.\nInformation on how to install VSS-tools in Windows is found in the Win-setup directory.\nAlignment with other standards The terminology used in these HIM based specifications should try to align with terminology and principles from other standards. The cases that has been identified are described below.\nAxle and tire locations The ISO xxxx(number and link missing) specification includes a centerline based approach for commercial vehicles, see diagram below. The ISO naming conventions shown in the figure above can be realized by providing the configuration shown below as input to the HIM configurator, and inserting the \u0026ldquo;instances0/1\u0026rdquo; directives in the related vspec files.\n\u0026#34;instances\u0026#34;: { \u0026#34;Axle\u0026#34;: [ \u0026#34;Row[1,4]\u0026#34;, [ [\u0026#34;Pos7\u0026#34;,\u0026#34;Pos9\u0026#34;], [\u0026#34;Pos7\u0026#34;,\u0026#34;Pos9\u0026#34;], [\u0026#34;Pos6\u0026#34;,\u0026#34;Pos7\u0026#34;, \u0026#34;Pos9\u0026#34;,\u0026#34;Pos10\u0026#34;], [\u0026#34;Pos8\u0026#34;] ] ] } Further references, e.g. TMC VMRS, Fleet location codes, etc\u0026hellip;\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]