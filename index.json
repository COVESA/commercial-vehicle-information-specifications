[
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/bus_tree/",
	"title": "Bus tree",
	"tags": [],
	"description": "",
	"content": "The bus tree The vspec bus tree is a super tree that contains signal definitions for a large set of different bus models. The HIM configurator is then used to create a signal tee for a specific bus variant.\nThe different bus variants that are present in the vspec files are:\nxxx "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/driver_tree/",
	"title": "Driver tree",
	"tags": [],
	"description": "",
	"content": "The Driver tree The vspec Driver tree \u0026hellip;.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/truck_tree/driver_tree/",
	"title": "Driver tree",
	"tags": [],
	"description": "",
	"content": "The driver tree The vspec driver tree is used to represent the truck driver data. The source for this driver data is the truck dirver recording unit (in europe often named tachograph, in the US xxx). As the driver recording unit may hold data not only for the current driver but also for previous drivers, there might be several instances of this driver tree, one for each driver that the driver recording unit has a record on. The data from these different instances should be accessible via the interface that is exposed by vehicle server managing the access to the driver recording device.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/him_configurator/",
	"title": "HIM configurator",
	"tags": [],
	"description": "",
	"content": "HIM configurator Build instructions To build the HIM configurator it is necessary to first instal the Golang build system. Searching on \u0026ldquo;install golang\u0026rdquo; will lead to many matches of which one is:\nhttps://go.dev/doc/install\nTo build the HIM configurator, open a terminal and go to the spec/trees directory where the himConfigurator.go is stored, and issue the command\n$ go build -o himConfigurator\nInitializing the Python virtual environment The HIM configurator uses the VSS-tools exporters for the generation of the transformed vspec files. According to the instructions for this tool a Python virtual environment should be set up in which it then is run when exporting the vspec files to other formats. The work flow is to the first time initialize this environment, and then every time before running the HIM configurator activate the virtual environment, and when done terminate the virtual environment.\nIf the virtual environment has not been set up before on the computer, it could e. g. already has been used in a VSS context to transform vspec files, then the first time it needs to be created and configured. To create it issue the following command:\n$ python3 -m venv ~/.venv Then it needs to be configured for VSS-tools, which shall be done with the environment activated:\n$ source ~/.venv/bin/activate (.venv)$ pip install --pre vss-tools (.venv)$ deactivate The above is only needed to be done once. It might be necessary to install both python and pip if that is not already installed on the computer.\nTo then use the HIM configurator it is sufficient with activating the virtual environment before using the HIM configurator.\n$ source ~/.venv/bin/activate Then the HIM configurator can be run in the spec/trees directory with commands like:\n(.venv)$ ./himConfigurator -m binary -v Vehicle/Trailer/ Finally the environment shall be deactivated it after the use.\n(.venv)$ deactivate If the HIM configurator complains with error logs it may help to, one time, try the command:\n(.venv)$ pip install -e . A bash script file in the spec/trees directory, venv.sh, can be used instead of typing the commands manually in the terminal window. If this file is issued as shown below it responds with displaying the two supported usages.\n$ source venv.sh usage: source venv.sh startme|installme As shown it can either be used to install venv, which as described above is only needed to be run the very first time. The other alternative can thereafter be used to activate venv.\nUsing the HIM configurator Starting the HIM configurator with the command:\n(.venv)$ ./himConfigurator -h\nwill show the command line options that is possible to apply at startup.\nusage: print [-h|--help] [-m|--makecommand (all|yaml|json|csv|binary)] [-c|--configfile \u0026#34;\u0026lt;value\u0026gt;\u0026#34;] [-r|--rootdir \u0026#34;\u0026lt;value\u0026gt;\u0026#34;] [-v|--vspec] [-p|--preprocess] [-n|--noEnumSubst] [-d|--defaultdatafile \u0026#34;\u0026lt;value\u0026gt;\u0026#34;] HIM configurator Arguments: -h --help Print help information -m --makecommand Make command parameter must be either: all, yaml, json, csv, or binary. Default: yaml -c --configfile configuration file name. Default: himConfig-truck.json -r --rootdir path to vspec root directory. Default: Vehicle/VSS-core/ -v --vspec Saves the configured .vspec2 files with extension .vspec -p --preprocess Pre-process only, save configured vspec files. Do not run VSS-tools. -n --noEnumSubst No substitution of enum links to Datatype tree with actual datatypes -d --defaultdatafile Default values file name The -m command line option is used to set which VSS-tools exporter the configured tree should have. The value \u0026lsquo;all\u0026rsquo; leads to that all the exporters that are compatible with the HIM configurator are executed. If not used the default is \u0026lsquo;yaml\u0026rsquo;.\nThe -c command line option is used to select the HIM configurator file. This is useful when a tree has multiple configuration files. Default is himConfig-truck.json.\nThe -r command line option is used to set the path to the tree that should be used as input for the configuration. The path is relative to the tree directory, and should have the slash \u0026lsquo;/\u0026rsquo; character at the end of the path. If not used the default is \u0026lsquo;Vehicle/VSS-core/\u0026rsquo;.\nIf the -v command is set the the HIM configurator does not delete the vspec files that it generates from the vspec2 files that are found in the tree structure. If not set these vspec files are deleted after being used as input to the call of the VSS-tools exporter(s). If not used the default is false, i. e. not to save the files.\nWith the vspec files saved it becomes possible to run the VSS-tols exporters \u0026ldquo;manually\u0026rdquo; with the vspec root node as input. This might be helpful if the development environment is not a Linux compatible environment, or if there is a need to debug the VSS-tools processing, se below.\nThe -p command leads to that the HIM configurator does not issue a command to the VSS-tools exporters. If the -v command also was set, then the vspec files generated by the HIM configurator is saved, see above, and the VSS-tools exporters can be activated \u0026ldquo;manually\u0026rdquo; with the pre-processed tree as input.\nThe -n command line option is used if substitution is not desired of the external datatype references with the actual enum definitions from the common Datatypes tree in the generated tree(s). However, VSS-tools currently does not accept the syntax using a reference.\nThe -d command line option is used to configure nodes with a default value that is defined in the named file.\nVSS-tools debug \u0026lsquo;in the development of the trees it might happen that errors are introdued in the vspec2/vspec files. VSS-tools have a compehensive error logging support, but this does not show up in the HIM configurator UI. It is however possible to get this error logging support by manually issuing a make command in a terminal window on the make file in the cvis root catalog, after first running the HIM configurator on the tree under development, with the -v CLI parameter so that the vspec files are saved. The make command shall then have the following general format:\nmake yaml VSPECROOT=./spec/trees/Vehicle/Truck/TruckSignalSpecification.vspec where yaml can be replaced by any other supported exporter, and the path to the root vspec file could be to any tree in the CVIS \u0026ldquo;forest\u0026rdquo;. The VSS-tools error logging will then be shown in the terminal window.\nCreation of a vehicle variant specific signal tree The HIM configurator enables a model where a \u0026ldquo;super tree\u0026rdquo; covering all variations that a vehicle may be equipped with, e. g. propulsion technology like ICE, PHEV, EV, etc. can be defined in the vspec files, then the HIM configurator can be used to create a \u0026ldquo;variant specific\u0026rdquo; vehicle signal tree from the variation point configuration in the himConfiguration.json file.\nUsage of a vehicle variant specific signal tree The output from the HIM configurator is the selected parts of the \u0026ldquo;vspec super tree\u0026rdquo; in a file with one of the supported formats. This file can then e. g. be used in a vehicle of the selected variant by a server that is managing the access to the signals. The server can then use the tree to \u0026ldquo;vet\u0026rdquo; client request - checking that the signal is present, whether it is read-only or read-write, that credentials are valid if access control is applied, etc. An example of a server using it like this is the VISS reference server.\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/trailer_tree/",
	"title": "Trailer tree",
	"tags": [],
	"description": "",
	"content": "The trailer tree The vspec trailer tree is a super tree that contains signal definitions for a large set of different trailer models. The HIM configurator is then used to create a signal tee for a specific trailer variant.\nThe different variants that are present in the vspec files are:\nFlatbed trailer: This trailer type has an open flat bed cargo unit. Box trailer: This trailer type has a cargo unit that is covered by walls and a roof. Tanker trailer: This trailer type has a cargo unit that is specicialized for carrying liquid cargos. Freezer trailer: This trailer type has a cargo unit that is specicialized for carrying cargos that require cooling. Specialized trailer: This trailer type has a cargo unit that does not match with any of the other types\u0026hellip; "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/truck_tree/",
	"title": "Truck tree",
	"tags": [],
	"description": "",
	"content": "The truck tree The vspec truck tree is a super tree that contains signal definitions for a large set of different truck models. The HIM configurator is then used to create a signal tee for a specific truck variant.\nThe different variants that are present in the vspec files are:\nTow truck: This truck type does not have an integrated cargo unit, but instead it is temporarily connected to a trailer (which defines its own signal tree). Flatbed truck: This truck type has an open flat bed cargo unit that is integrated with the rest of the truck. Box truck: This truck type has a cargo unit that is covered by walls and a roof that is integrated with the rest of the truck. Pickup truck: The model would support pickup trucks to be defined here also\u0026hellip; Van: The model would support vans to be defined here also\u0026hellip; "
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/",
	"title": "Commercial Vehicle Information Specifications",
	"tags": [],
	"description": "",
	"content": "Commercial Vehicle Information Specifications Overview The ambition of the CVIS project is to develop a framework that can be used to define signal trees for different vehicle types, and then to use this framework to develop signal trees for vehicle types as e. g. Trucks, Trailers, Buses, and Passenger cars. The trees for these vehicle types shall share as much as possible of signals that can be commonly defined. The basis for common signals shall be the VSS tree. This tree has a focus on signals for passenger cars, but a significant part of these can very well be shared with the other vehicle types.\nThe CVIS project uses the Resource profile of the Hierarchical Information Model [HIM), which is fully compatible with the VSS rule set.\nThe basis of the framework that can be used to define signal trees for different vehicle types is the HIM configurator. It works as a pre-processor that reads the extended vspec format, vspec2, and processes the extended instruction set described below from which it generates vspec formatted files which are applied as input to the VSS-tools exporters to generate fully configured trees for desired vehicle types and models.\nThe HIM configuration instructions are declared in JSON formatted files. These instructions can be applied to trees that have a pre-configured vehicle type specific structure, or that have a vehicle type agnostic structure. The VSS-core tree is an example of the latter, while the other trees in the Vehicle directory have a pre-configure vehicle type specific structure.\nA tree, whether it is vehicle type specific or not, shall be located on the spec/trees directory structure. These trees may then link to common objects which shall be located on the spec/objects directory structure.\nThe linking to common objects use the symbolic linking file system feature, which have differen syntax in Linux and Windows, see more in the Symlink chapter below.\nSymbolic linking The directory structure for a single tree follows the VSS pattern with \u0026ldquo;#include\u0026rdquo; links in the vspec files that logically links to other files of the tree. However, to link to a file in the common objects structure the corresponding file in the trees structure is realized as a symbolic link file. This means that when the content of the file is accessed the underlying file system follows the symbolic link to the file in the objects structure for the actual content of the file. This is transparent to the entity accessing the file, so e. g. the exporter tools from VSS-tools will when used for a transformation of a specific tree access file content from the common objects files transparently.\nThe symbolic links used in a tree structure definition shall be declared in a script file that can be run to refresh the symlinks if a link is broken. The syntax of these script files differ between Linux and Windows, see the chapter below.\nLinux / Windows specific parts Symlink script files The symlink cript files used in Linux are standard bash script files, see e. g. cv-truck-symlinks.sh.\nFor Windows a Powershell](https://en.wikipedia.org/wiki/PowerShell) script is used, see e. g. cv-truck-symlink.ps1.\nVSS-tools activation The HIM configurator activates the VSS-tools exporter via a Makefile.\nIn Windows the setup for VSS-tools activation is done by following the instructions found in the Win-setup directory.\nTree development The HIM rule set for resource data is used to define signals in a tree. This syntax can be directly used as input to any of the exporter tools provided by VSS-tools.\nHIM extensions The HIM syntax is in this project extended with the features described below. These can be preprocessed by the HIM configurator which transforms them into a HIM compliant format, thus making it possible to use the SS-tools for exporting to other formats. If these extensions are found to be useful it is likely that they will become included in the HIM standard rule set for resurce data.\nThe rules for when the file extension \u0026ldquo;vspec2\u0026rdquo; shall be used instead of \u0026ldquo;vspec\u0026rdquo; are the following:\nA file that contains any extended syntax must be named with the file extension \u0026ldquo;vspec2\u0026rdquo; If a vspec2 file is referenced from within another file then this reference shall use the extension vspec if this file is located in the \u0026ldquo;trees\u0026rdquo; directory strucure. If a vspec2 file is referenced from within another file then this reference shall use the extension vspec2 if this file is located in the \u0026ldquo;objects\u0026rdquo; directory strucure. Extension 1: Variability configuration The tree in vspec format may contain multiple variations of objects that in a deployment typically are not included. An example are the Combustion engine and the Electric engine. in an ICE vehicle the former should be included, but not the latter. For an EV vehicle it is vice versa. To enable one or the other of these objects to be included the following syntax is used, example taken from the Engine.vspec.\nVariationPoint: #EngineType - ICE #include CombustionEngine.yaml Engine - EV #include ElectricEngine.vspec Engine The keyword is VariationPoint, which on the same line must be followed by a hash sign (#) directly followe by a unique variation point tag (in this case EngineType. The value part of this key-value expression is an array of \u0026lsquo;variability object expressions\u0026rsquo;, where such an expression contains a \u0026lsquo;variability name\u0026rsquo; followed by an \u0026lsquo;#include expression\u0026rsquo;. This expression must be compliant with the syntax rules for HIM #include expressions. The array size is not restricted.\nThe input to the HIM configurator for it to resolve which variations to select is found in two files.\nThe Variability.json file, and the himConfiguration.json file. The Variability.json file defines the available variations, and which include statements that should be selected for the variation. As can be seen in th PHEV variation example below it is possible to select multiple include statements.\n\u0026#34;EngineType\u0026#34;: [ { \u0026#34;PHEV\u0026#34;: [ \u0026#34;ICE\u0026#34;, \u0026#34;EV\u0026#34; ] } The himConfiguration.json file contains the variation that that should be included in the tree that is generated by the himConfigurator (using a VSS-tools exporter), expressed by the rows below in this example:\n\u0026#34;variants\u0026#34;: { \u0026#34;EngineType\u0026#34;: \u0026#34;PHEV\u0026#34; Extension 2: Instantiation configuration The HIM rule set supports the instantiation syntax inherited from VSS instantiation that can be used to request the VSS-tools to generate multiple instances of a branch/set of signals. This syntax has two options exemplified below\ninstances: [\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;] instances: Row[1,2] The examples above can be extended to two dimensions by using the array syntax, e.g. instances: - Row[1,2] - [\u0026#34;DriverSide\u0026#34;, \u0026#34;PassengerSide\u0026#34;] which will generate a structure with four branches - Row1:DriverSide, Row1:PassengerSide, Row2:DriverSide, Row2:PassengerSide. It is however not possible to use this syntax to express a configuration where for Row1 there are two child nodes, e.g. [\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;], and for Row2 there are three child nodes, e. g. [\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;Middle\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;].\nThis missing flexibility is however provided in the extended syntax supported by the HIM configurator. A two-dimensional instantiation is then expressed in the vspec file as:\ninstances0: x #instanceTag instances1: x #instanceTag where \u0026lsquo;instances0\u0026rsquo; is used for the \u0026lsquo;first-order\u0026rsquo; instantiation (Row[1,2] in the example above), and \u0026lsquo;instances1\u0026rsquo; is used for the \u0026lsquo;second-order\u0026rsquo; instantiation ([\u0026ldquo;DriverSide\u0026rdquo;, \u0026ldquo;PassengerSide\u0026rdquo;] in the example above).\n\u0026lsquo;x\u0026rsquo; is a placeholder for the instance expression in the file himConfiguration.json that is the input to the HM configurator, and \u0026lsquo;instanceTag\u0026rsquo; is a unique name logically linking the two expressions, which must be preceded by a hash character (#). The two instance expressions can, but must not be on two subsequent rows. If not, then the second expression must be defined in any of the nodes that is part of the subtree under the node containing the first expression. The instance configuration input to the HIM configurator has a syntax as exemplified below.\n\u0026#34;instances\u0026#34;: { \u0026#34;Seat\u0026#34;: [ \u0026#34;Row[1,2]\u0026#34;, [ [ \u0026#34;DriverSide\u0026#34;, \u0026#34;PassengerSide\u0026#34; ], [ \u0026#34;DriverSide\u0026#34;, \u0026#34;Middle\u0026#34;, \u0026#34;PassengerSide\u0026#34; ] ] ] } The \u0026lsquo;Seat\u0026rsquo; shown above is the instanceTag name that the HIM configurator will try to match in the vspec file.\nThe \u0026lsquo;first-order\u0026rsquo; instantiation, in this case \u0026ldquo;Row[1,2]\u0026rdquo;, is followed by two \u0026lsquo;second-order\u0026rsquo; instantiation expressions.\nThe number of \u0026lsquo;second-order\u0026rsquo; expressions must match the number of instantiaions that the \u0026lsquo;first-order\u0026rsquo; expression will expand to.\nThe expressions can use any of the two syntax options mentioned above.\nCurrently this syntax can only be used for two-dimensional instantiations.\nExtension 3: Local variation point If an instantiation configuration has a need of including a variation point with different variants for the different intances then the Variation point feature described above cannot be used as it would apply the same variant to all instances. To meet this need the Local Variation point (LocalVP) is available. An expression like shown below is inserted in the subtree to be instantiated\nLocalVP: #AxleFeature - LIFTABLE #include Liftable.vspec Axle - STEERABLE #include Steerable.vspec Axle - DRIVING #include Driving.vspec Axle The himConfiguration.json file is then updated with the different configurations for the different instances as shown below.\n\u0026#34;variants\u0026#34;: { \u0026#34;AxleFeature.Row1\u0026#34;: \u0026#34;AXLE+STEER\u0026#34;, \u0026#34;AxleFeature.Row2\u0026#34;: \u0026#34;AXLE+LIFT\u0026#34;, \u0026#34;AxleFeature.Row3\u0026#34;: \u0026#34;AXLE+STEER+DRIVE\u0026#34; } As seen the AxlePoint local varation point name is extended with the names of the different instances Row1..Row3, which must be the same as the instantiation is configured with. The Variability.json shall then contain the definition of which include alternatives in the LocalVP command that shall be included.\n\u0026#34;AxleFeature\u0026#34;: [ { \u0026#34;AXLE\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;AXLE+LIFT\u0026#34;: \u0026#34;LIFTABLE\u0026#34; }, { \u0026#34;AXLE+STEER\u0026#34;: \u0026#34;STEERABLE\u0026#34; }, { \u0026#34;AXLE+DRIVE\u0026#34;: \u0026#34;DRIVING\u0026#34; }, { \u0026#34;AXLE+LIFT+STEER\u0026#34;: [ \u0026#34;LIFTABLE\u0026#34;, \u0026#34;STEERABLE\u0026#34; ] }, { \u0026#34;AXLE+LIFT+DRIVE\u0026#34;: [ \u0026#34;LIFTABLE\u0026#34;, \u0026#34;STEERABLE\u0026#34; ] }, { \u0026#34;AXLE+STEER+DRIVE\u0026#34;: [ \u0026#34;STEERABLE\u0026#34;, \u0026#34;DRIVING\u0026#34; ] }, { \u0026#34;AXLE+LIFT+STEER+DRIVE\u0026#34;: [ \u0026#34;LIFTABLE\u0026#34;, \u0026#34;STEERABLE\u0026#34;, \u0026#34;DRIVING\u0026#34; ] } ] With the above in place the HIM configurator will create the different variants for the different instances.\nExtension 4: Allowed datatype reference One of the information rule sets that HIM supports is the type definition rule set. A type definition tree is able to define structs and enums (allowed) that can be referenced from trees of other information types. Such a tree is defined in the spec/objects/Datatypes directory, currently containing the enums (allowed) that is used in the VSS tree. This tree has a structure that mirrors the structure from the VSS tree where the enums were originally used. This structure might later be changed to a more generic structuring to yield reference path names more decoupled from the VSS structure.\nAn external datatype reference to an enum (allowed) shall have a syntax as shown below.\ndatatype: Datatype.x.y.zValues where x, y, z may be names providing an understanding of the defined enum (allowed) that conform to the node HIM node name syntax. The name z must be postfixed with the tag Values.\nIf the HIM configurator is used to substitute external enum (Allowed) references it will create a Datatype.yaml file in the root directory of the signal tree that it is working on. The node type in a type definition tree shall be \u0026lsquo;property\u0026rsquo; but due to that the VSS-tools will reject separate trees with that node type, the node type \u0026lsquo;sensor\u0026rsquo; is used instead. This must therefore be manually edited to rename to \u0026lsquo;property\u0026rsquo; until a moodified version of VSS-tools is created, or that the HIM configurator is updated to handle the node type renaming.\nExtension 5: Configuration of default values It is allowed according the the HIM rule set to include default values in the node definitions. This is mainly meant to be used for nodes of the node type attribute, but can also be applied to the node types sensor and actuator. To define that a node shall be configured with a default value, a JSON expression like the example below must be added to a JSON file stored in the tree directory, see defaultValues.json as an example.\n{ \u0026#34;path\u0026#34;: \u0026#34;Vehicle.Cabin.DoorCount\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;6\u0026#34; } The default configuration file is specified in the CLI command when starting the HIM configurator following the -d tag.\nIf the tree already has a default value for a node that is in the list it will be replaced by the new value, otherwise a default line is added to the node.\nTrees under development Currently two trees are being developed:\nTruck tree Trailer tree Bus tree Driver tree VSS-core tree The VSS-core tree is a vehicle type agnostic tree that is configured by the HIM configurator to become vehicle type specific. Configuration templates for the vehicle types Car and Truck are available, and can be used as starting poin to create templates for other vehicle types.\nThe other trees are vehicle type specific from the start, or for Driver a supplementary tree to be used together with e. g. the Truck tree.\nHIM configurator The framework also contains a new tool, the HIM configurator. In its current version it provides support for two types of tree configuration:\nVariation point configuration: If the tree defined by the vspec files contains data structures that are not typically used together in a specific deployment of the tree, then these can be tagged as a variability point, and the HIM configurator can be used to pick the desired structure(s). Instance configuration: This is an extension of the existing VSS-tools instance support that provides the possibility for a two dimensional instantiation to have unique \u0026ldquo;column instantiation\u0026rdquo; for each \u0026ldquo;row instantiation\u0026rdquo;. Check out the HIM configurator chapter for more details.\nIf this new tool is found to be useful it is planned to add support for \u0026ldquo;default configuration\u0026rdquo; later.\nAlignment with other standards The terminology used in these HIM based specifications should try to align with terminology and principles from other standards. The cases that has been identified are described below.\nAxle and tire locations The ISO xxxx(number and link missing) specification includes a centerline based approach for commercial vehicles, see diagram below. The ISO naming conventions shown in the figure above can be realized by providing the configuration shown below as input to the HIM configurator, and inserting the \u0026ldquo;instances0/1\u0026rdquo; directives in the related vspec files.\n\u0026#34;instances\u0026#34;: { \u0026#34;Axle\u0026#34;: [ \u0026#34;Row[1,4]\u0026#34;, [ [\u0026#34;Pos7\u0026#34;,\u0026#34;Pos9\u0026#34;], [\u0026#34;Pos7\u0026#34;,\u0026#34;Pos9\u0026#34;], [\u0026#34;Pos6\u0026#34;,\u0026#34;Pos7\u0026#34;, \u0026#34;Pos9\u0026#34;,\u0026#34;Pos10\u0026#34;], [\u0026#34;Pos8\u0026#34;] ] ] } Further references, e.g. TMC VMRS, Fleet location codes, etc\u0026hellip;\n"
},
{
	"uri": "https://covesa.github.io/commercial-vehicle-information-specifications/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]